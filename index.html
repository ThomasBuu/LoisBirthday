<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chasse au trésor GPS</title>
  <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    .text-xxs {
      font-size: 0.65rem;
    }
    .overflow-x-auto::-webkit-scrollbar {
      height: 4px;
    }
    .overflow-x-auto::-webkit-scrollbar-thumb {
      background-color: rgba(156, 163, 175, 0.5);
      border-radius: 2px;
    }
    .overflow-x-auto::-webkit-scrollbar-track {
      background-color: rgba(229, 231, 235, 0.5);
    }
    @media (max-width: 640px) {
      .grid-item-small {
        width: 22px;
        height: 22px;
      }
    }
    .max-w-crossword {
      max-width: 300px;
      margin: 0 auto;
    }
  </style>
</head>
<body class="bg-gray-100">
  <div id="root"></div>
  
  <script type="text/babel">
    // Composant de mot croisé
    const CrosswordPuzzle = ({ onSolve, debugMode }) => {
      const [userAnswers, setUserAnswers] = React.useState([]);
      const [isSolved, setIsSolved] = React.useState(false);
      const [gridData, setGridData] = React.useState(null);
      const [focusedCell, setFocusedCell] = React.useState(null);
      const [error, setError] = React.useState(null);
      
      // Initialisation de la grille
      React.useEffect(() => {
        try {
          // Données de la grille de mots croisés
          const data = {
            "grid": [
              [
                { "type": "black" }, { "type": "black" }, { "type": "white", "number": 1 }, { "type": "black" }, { "type": "black" }, 
                { "type": "white", "number": 2 }, { "type": "black" }, { "type": "white", "number": 3 }, { "type": "white" }, 
                { "type": "white", "number": 4 }, { "type": "black" }, { "type": "black" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "white" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "white" }, 
                { "type": "black" }, { "type": "black" }
              ],
              [
                { "type": "white", "number": 5 }, { "type": "white" }, { "type": "white" }, { "type": "white" }, { "type": "white" }, 
                { "type": "white" }, { "type": "white" }, { "type": "white" }, { "type": "black" }, { "type": "white" }, 
                { "type": "black" }, { "type": "black" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "white" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "white" }, 
                { "type": "black" }, { "type": "black" }
              ],
              [
                { "type": "white", "number": 6 }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "white" }, { "type": "black" }, { "type": "white", "number": 7 }, { "type": "black" }, { "type": "white" }, 
                { "type": "black" }, { "type": "black" }
              ],
              [
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "white", "number": 8 }, 
                { "type": "white" }, { "type": "white" }, { "type": "white" }, { "type": "white" }, { "type": "white" }, 
                { "type": "white", "number": 9 }, { "type": "white" }
              ],
              [
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "white", "number": 10 }, { "type": "white" }, { "type": "white" }, { "type": "white" }, { "type": "white" }, 
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white", "number": 11 }, { "type": "white" }, { "type": "white" }, { "type": "white" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ]
            ],
            "clues": {
              "across": [
                { "number": 3, "clue": "Album préféré de Loïs" },
                { "number": 5, "clue": "Ville et couleur" },
                { "number": 8, "clue": "Vrai prénom de Dan" },
                { "number": 10, "clue": "Animal préféré de Loïs" },
                { "number": 11, "clue": "Dans quelle ville est NÉ Loïs" }
              ],
              "down": [
                { "number": 1, "clue": "Film d'horreur/slasher pref de Loïs" },
                { "number": 2, "clue": "Alcool préféré de Loïs" },
                { "number": 4, "clue": "i m not a drag queen I m the queen of drag" },
                { "number": 6, "clue": "Taylor" },
                { "number": 7, "clue": "macaque tibétain manchot" },
                { "number": 9, "clue": "Boutique ou Loïs travaille" }
              ]
            }
          };
          
          // Initialiser les tableaux pour les réponses utilisateur
          const emptyAnswers = data.grid.map(row => 
            row.map(cell => cell.type === "white" ? "" : null)
          );
          
          setGridData(data);
          setUserAnswers(emptyAnswers);
        } catch (err) {
          setError("Erreur lors du chargement des données: " + err.message);
        }
      }, []);
      
      // Solutions attendues avec les tailles correctes
      const expectedSolutions = {
        "across": {
          3: "AAA",
          5: "AAAAAAAA",
          8: "AAAAAAAA",
          10: "AAAAAA",
          11: "AAAA"
        },
        "down": {
          1: "AAAAAAAAA",
          2: "AAAAAAAAA",
          4: "AAAAAA",
          6: "AAAAA",
          7: "AAAAAAAA",
          9: "AAAAAAAA"
        }
      };
      
      // Fonction pour remplir automatiquement une réponse (triche)
      const fillAnswer = (direction, number) => {
        // Obtenir la solution attendue
        const solution = expectedSolutions[direction][number];
        if (!solution) return;
        
        // Trouver la position de départ
        let startPos = null;
        for (let i = 0; i < gridData.grid.length; i++) {
          for (let j = 0; j < gridData.grid[i].length; j++) {
            if (gridData.grid[i][j].type === "white" && 
                gridData.grid[i][j].number === number) {
              startPos = { row: i, col: j };
              break;
            }
          }
          if (startPos) break;
        }
        
        if (!startPos) return;
        
        // Créer une copie des réponses actuelles
        const newAnswers = [...userAnswers];
        
        // Remplir les cases selon la direction
        if (direction === "across") {
          // Horizontal (de gauche à droite)
          for (let i = 0; i < solution.length; i++) {
            const col = startPos.col + i;
            if (col < gridData.grid[startPos.row].length && 
                gridData.grid[startPos.row][col].type === "white") {
              newAnswers[startPos.row][col] = solution[i];
            }
          }
        } else if (direction === "down") {
          // Vertical (de haut en bas)
          for (let i = 0; i < solution.length; i++) {
            const row = startPos.row + i;
            if (row < gridData.grid.length && 
                gridData.grid[row] && 
                gridData.grid[row][startPos.col] && 
                gridData.grid[row][startPos.col].type === "white") {
              newAnswers[row][startPos.col] = solution[i];
            }
          }
        }
        
        setUserAnswers(newAnswers);
      };
      
      // Remplir toute la grille en un clic (bouton "Triche complète")
      const fillAllAnswers = () => {
        // Remplir d'abord les mots horizontaux
        Object.keys(expectedSolutions.across).forEach(number => {
          fillAnswer("across", parseInt(number));
        });
        
        // Puis les mots verticaux
        Object.keys(expectedSolutions.down).forEach(number => {
          fillAnswer("down", parseInt(number));
        });
        
        // Vérifier automatiquement après remplissage complet
        setTimeout(() => checkSolution(), 300);
      };
      
      // Gérer les entrées utilisateur
      const handleInputChange = (rowIndex, colIndex, value) => {
        // Accepter uniquement une lettre
        if (value.length > 1) {
          value = value.charAt(value.length - 1);
        }
        
        // Convertir en majuscule
        value = value.toUpperCase();
        
        // Mettre à jour les réponses de l'utilisateur
        const newAnswers = [...userAnswers];
        newAnswers[rowIndex][colIndex] = value;
        setUserAnswers(newAnswers);
        
        // Si une lettre a été saisie, déplacer le focus vers la cellule suivante
        if (value !== "") {
          moveToNextCell(rowIndex, colIndex);
        }
      };
      
      // Fonction pour gérer la touche Backspace et les flèches
      const handleKeyDown = (e, rowIndex, colIndex) => {
        if (e.key === "Backspace" && userAnswers[rowIndex][colIndex] === "") {
          e.preventDefault();
          moveToPrevCell(rowIndex, colIndex);
        } else if (e.key === "ArrowRight") {
          e.preventDefault();
          moveHorizontal(rowIndex, colIndex, 1);
        } else if (e.key === "ArrowLeft") {
          e.preventDefault();
          moveHorizontal(rowIndex, colIndex, -1);
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          moveVertical(rowIndex, colIndex, -1);
        } else if (e.key === "ArrowDown") {
          e.preventDefault();
          moveVertical(rowIndex, colIndex, 1);
        }
      };
      
      // Déplacer vers la cellule suivante (horizontalement)
      const moveToNextCell = (rowIndex, colIndex) => {
        // Essayer de trouver la prochaine cellule blanche horizontalement
        let nextCol = colIndex + 1;
        while (nextCol < gridData.grid[rowIndex].length) {
          if (gridData.grid[rowIndex][nextCol].type === "white") {
            focusCell(rowIndex, nextCol);
            return;
          }
          nextCol++;
        }
        
        // Si pas trouvé, essayer la ligne suivante
        let nextRow = rowIndex + 1;
        while (nextRow < gridData.grid.length) {
          for (let col = 0; col < gridData.grid[nextRow].length; col++) {
            if (gridData.grid[nextRow][col].type === "white") {
              focusCell(nextRow, col);
              return;
            }
          }
          nextRow++;
        }
      };
      
      // Déplacer vers la cellule précédente
      const moveToPrevCell = (rowIndex, colIndex) => {
        let prevCol = colIndex - 1;
        while (prevCol >= 0) {
          if (gridData.grid[rowIndex][prevCol].type === "white") {
            focusCell(rowIndex, prevCol);
            return;
          }
          prevCol--;
        }
        
        // Si pas trouvé, essayer la ligne précédente
        let prevRow = rowIndex - 1;
        while (prevRow >= 0) {
          for (let col = gridData.grid[prevRow].length - 1; col >= 0; col--) {
            if (gridData.grid[prevRow][col].type === "white") {
              focusCell(prevRow, col);
              return;
            }
          }
          prevRow--;
        }
      };
      
      // Déplacer horizontalement
      const moveHorizontal = (rowIndex, colIndex, direction) => {
        let nextCol = colIndex + direction;
        while (nextCol >= 0 && nextCol < gridData.grid[rowIndex].length) {
          if (gridData.grid[rowIndex][nextCol].type === "white") {
            focusCell(rowIndex, nextCol);
            return;
          }
          nextCol += direction;
        }
      };
      
      // Déplacer verticalement
      const moveVertical = (rowIndex, colIndex, direction) => {
        let nextRow = rowIndex + direction;
        while (nextRow >= 0 && nextRow < gridData.grid.length) {
          if (gridData.grid[nextRow][colIndex].type === "white") {
            focusCell(nextRow, colIndex);
            return;
          }
          nextRow += direction;
        }
      };
      
      // Mettre le focus sur une cellule
      const focusCell = (rowIndex, colIndex) => {
        setFocusedCell({ row: rowIndex, col: colIndex });
        
        setTimeout(() => {
          const input = document.getElementById(`cell-${rowIndex}-${colIndex}`);
          if (input) {
            input.focus();
          }
        }, 0);
      };
      
      // Vérifier si le mot croisé est correctement rempli
      const checkSolution = () => {
        // Pour faciliter les tests, considérer comme correct si au moins 70% des lettres sont saisies
        let filledCells = 0;
        let totalCells = 0;
        
        // Compter les cellules remplies
        for (let i = 0; i < gridData.grid.length; i++) {
          for (let j = 0; j < gridData.grid[i].length; j++) {
            if (gridData.grid[i][j].type === "white") {
              totalCells++;
              if (userAnswers[i][j] && userAnswers[i][j] !== "") {
                filledCells++;
              }
            }
          }
        }
        
        // Calculer le pourcentage de remplissage
        const fillPercentage = (filledCells / totalCells) * 100;
        
        // Si au moins 70% des cellules sont remplies, considérer comme résolu
        if (fillPercentage >= 70) {
          setIsSolved(true);
          if (onSolve) {
            onSolve("I"); // Retourne la lettre "I" correspondant à l'énigme de la grotte
          }
        } else {
          alert(`La grille est remplie à ${Math.round(fillPercentage)}%, il faut au moins 70% pour valider. Continuez !`);
        }
      };
      
      // Si les données ne sont pas encore chargées
      if (!gridData) {
        return <div>Chargement du mot croisé...</div>;
      }
      
      // Si une erreur est survenue
      if (error) {
        return <div className="text-red-600">{error}</div>;
      }
      
      return (
        <div className="p-4 bg-white rounded-xl shadow">
          <h3 className="text-xl font-bold mb-4">Mot Croisé - La Grotte</h3>
          
          {isSolved ? (
            <div className="bg-green-100 p-4 rounded text-green-800 mb-4">
              <p className="font-bold">Bravo ! Vous avez résolu le mot croisé.</p>
              <p>Vous avez obtenu la lettre : <span className="text-2xl font-bold">I</span></p>
            </div>
          ) : (
            <div className="mb-4">
              <p className="text-gray-700 mb-2">
                Remplissez le mot croisé pour débloquer l'indice de la grotte.
              </p>
              {debugMode && (
                <button 
                  onClick={fillAllAnswers}
                  className="mt-2 bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-2 rounded text-sm"
                >
                  Triche complète
                </button>
              )}
            </div>
          )}
          
          <div className="flex flex-col gap-4">
            {/* Grille de mot croisé */}
            <div className="w-full overflow-x-auto pb-2">
              <div className="max-w-crossword">
                <div 
                  className="grid gap-px bg-gray-300 inline-block mx-auto"
                  style={{ 
                    gridTemplateRows: `repeat(${gridData.grid.length}, 25px)`,
                    gridTemplateColumns: `repeat(${gridData.grid[0].length}, 25px)`
                  }}
                >
                  {gridData.grid.map((row, rowIndex) => (
                    row.map((cell, colIndex) => (
                      <div
                        key={`${rowIndex}-${colIndex}`}
                        className={`relative flex items-center justify-center grid-item-small
                          ${cell.type === "black" ? "bg-black" : "bg-white"}
                          ${focusedCell && focusedCell.row === rowIndex && focusedCell.col === colIndex 
                            ? "ring-1 ring-blue-500" : ""}
                        `}
                        onClick={() => cell.type === "white" && focusCell(rowIndex, colIndex)}
                      >
                        {cell.type === "white" && cell.number && (
                          <span className="absolute top-0 left-0.5 text-xxs md:text-xs font-semibold text-gray-500">
                            {cell.number}
                          </span>
                        )}
                        
                        {cell.type === "white" && (
                          <input
                            id={`cell-${rowIndex}-${colIndex}`}
                            type="text"
                            maxLength="1"
                            className="w-full h-full text-center font-bold uppercase bg-transparent outline-none text-xs md:text-base"
                            value={userAnswers[rowIndex] && userAnswers[rowIndex][colIndex] ? userAnswers[rowIndex][colIndex] : ""}
                            onChange={(e) => handleInputChange(rowIndex, colIndex, e.target.value)}
                            onKeyDown={(e) => handleKeyDown(e, rowIndex, colIndex)}
                            disabled={isSolved}
                          />
                        )}
                      </div>
                    ))
                  ))}
                </div>
                
                {!isSolved && (
                  <button 
                    onClick={checkSolution}
                    className="mt-4 w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded"
                  >
                    Vérifier la solution
                  </button>
                )}
              </div>
            </div>
            
            {/* Indices */}
            <div className="w-full">
              <div className="bg-gray-100 p-4 rounded">
                <div className="mb-4">
                  <h4 className="font-bold text-lg mb-2">Horizontalement</h4>
                  <ul className="space-y-2">
                    {gridData.clues.across.map((clue) => (
                      <li key={`across-${clue.number}`} className="flex items-center">
                        <span className="font-semibold mr-1">{clue.number}.</span> {clue.clue}
                        {debugMode && !isSolved && (
                          <button 
                            onClick={() => fillAnswer("across", clue.number)}
                            className="ml-2 bg-red-500 hover:bg-red-600 text-white font-bold py-0.5 px-1 rounded text-xs"
                          >
                            Triche
                          </button>
                        )}
                      </li>
                    ))}
                  </ul>
                </div>
                
                <div>
                  <h4 className="font-bold text-lg mb-2">Verticalement</h4>
                  <ul className="space-y-2">
                    {gridData.clues.down.map((clue) => (
                      <li key={`down-${clue.number}`} className="flex items-center">
                        <span className="font-semibold mr-1">{clue.number}.</span> {clue.clue}
                        {debugMode && !isSolved && (
                          <button 
                            onClick={() => fillAnswer("down", clue.number)}
                            className="ml-2 bg-red-500 hover:bg-red-600 text-white font-bold py-0.5 px-1 rounded text-xs"
                          >
                            Triche
                          </button>
                        )}
                      </li>
                    ))}
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    // Application principale de chasse au trésor
    const TreasureHunt = () => {
      const [currentPosition, setCurrentPosition] = React.useState(null);
      const [nearbyLocation, setNearbyLocation] = React.useState(null);
      const [error, setError] = React.useState(null);
      const [distance, setDistance] = React.useState(null);
      const [permissionStatus, setPermissionStatus] = React.useState('pending');
      const [userAnswer, setUserAnswer] = React.useState('');
      const [solvedLocations, setSolvedLocations] = React.useState([]);
      const [secretWord, setSecretWord] = React.useState('');
      const [gameCompleted, setGameCompleted] = React.useState(false);
      const [defaultQuestion, setDefaultQuestion] = React.useState(true);
      const [debugMode, setDebugMode] = React.useState(false);
      const [selectedDebugLocation, setSelectedDebugLocation] = React.useState(null);

      // Charger les lieux résolus depuis localStorage au démarrage
      React.useEffect(() => {
        const savedLocations = localStorage.getItem('solvedLocations');
        if (savedLocations) {
          setSolvedLocations(JSON.parse(savedLocations));
        }
      }, []);

      // Sauvegarder les lieux résolus dans localStorage à chaque mise à jour
      React.useEffect(() => {
        if (solvedLocations.length > 0) {
          localStorage.setItem('solvedLocations', JSON.stringify(solvedLocations));
        }
      }, [solvedLocations]);
      
      // Liste des lieux avec grotte modifiée pour utiliser le mot croisé
      const locations = [
        { 
          name: "Barques", 
          lat: 48.83300, 
          lng: 2.40986, 
          question: "Combien Loïs va-t-il payer individuellement si il va faire de la barque au lac de Dausmenil avec Luna pendant 3heures ?", 
          options: [
            "37,00€",
            "39,50€",
            "47,40€",
            "79,00€"
          ],
          answer: "39,50", 
          letter: "E",
          image: "https://picsum.photos/seed/barques/400/300" 
        },
        { 
          name: "Île des paons", 
          lat: 48.83105, 
          lng: 2.41189, 
          question: "Quel oiseau ne trouve-t-on pas sur le lac de daumesnil ?", 
          options: [
            "Oie de Guinée",
            "Canard colvert",
            "Foulque",
            "Cygne"
          ],
          answer: "Oie de Guinée", 
          letter: "N",
          image: "https://picsum.photos/seed/paons/400/300" 
        },
        { 
          name: "Grotte", 
          lat: 48.83003, 
          lng: 2.41575,
          usesCrossword: true, // Nouveau paramètre pour indiquer qu'on utilise un mot croisé
          question: "Complétez le mot croisé pour obtenir la lettre", 
          answer: "", // Pas besoin de réponse car géré par le composant de mot croisé
          letter: "I",
          image: "https://picsum.photos/seed/grotte/400/300" 
        },
        { 
          name: "Pèlerins des nuages et de l'eau", 
          lat: 48.82903, 
          lng: 2.41375, 
          question: "Dans un aquarium il y a 10 poissons rouges. 2 se sont noyés, 4 nagent entre les rochers et 3 sont morts. Combien de poissons rouges reste-t-il ?", 
          options: [
            "4",
            "5",
            "7",
            "10"
          ],
          answer: "10", 
          letter: "G",
          image: "https://picsum.photos/seed/pelerins/400/300" 
        },
        { 
          name: "Pont sud", 
          lat: 48.82845, 
          lng: 2.41837, 
          question: "L'île de Bercy est-elle un île artificielle ? Si oui en quelle année a-t-elle été créée ?", 
          options: [
            "Ce n'est pas une île artificielle mais elle a été découverte transformée en parc en 1690",
            "Ce n'est pas une île artificielle mais elle a été découverte transformée en parc en 1960",
            "Oui en 1960",
            "Oui en 1860"
          ],
          answer: "Oui en 1860", 
          letter: "M",
          image: "https://picsum.photos/seed/pontsud/400/300" 
        }
      ];

      // Fonction pour calculer la distance entre deux points GPS (formule de Haversine)
      const calculateDistance = (lat1, lon1, lat2, lon2) => {
        const R = 6371000; // Rayon de la Terre en mètres
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = 
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      };

      // Fonction pour vérifier la proximité des lieux
      const checkProximity = (position) => {
        if (!position) return;
        
        const { latitude, longitude } = position.coords;
        
        // Trouver le lieu le plus proche
        let closestLocation = null;
        let minDistance = Infinity;
        
        locations.forEach(location => {
          const dist = calculateDistance(latitude, longitude, location.lat, location.lng);
          if (dist < minDistance) {
            minDistance = dist;
            closestLocation = { ...location, distance: dist };
          }
        });
        
        setDistance(minDistance);
        
        // Considérer comme "proche" si moins de 100 mètres
        if (minDistance < 100) {
          setNearbyLocation(closestLocation);
          setDefaultQuestion(false);
        } else {
          setNearbyLocation(null);
          setDefaultQuestion(true);
        }
      };

      // Demander la géolocalisation
      const requestLocation = () => {
        setPermissionStatus('requesting');
        
        if (!navigator.geolocation) {
          setError("La géolocalisation n'est pas supportée par votre navigateur");
          setPermissionStatus('denied');
          return;
        }
        
        navigator.geolocation.getCurrentPosition(
          (position) => {
            setCurrentPosition(position);
            checkProximity(position);
            setPermissionStatus('granted');
            
            // Mettre à jour la position régulièrement
            const watchId = navigator.geolocation.watchPosition(
              (newPosition) => {
                setCurrentPosition(newPosition);
                checkProximity(newPosition);
              },
              (err) => {
                setError(`Erreur: ${err.message}`);
                setPermissionStatus('error');
              }
            );
            
            return () => navigator.geolocation.clearWatch(watchId);
          },
          (err) => {
            if (err.code === 1) { // PERMISSION_DENIED
              setPermissionStatus('denied');
            }
            setError(`Erreur: ${err.message}`);
          },
          { enableHighAccuracy: true }
        );
      };

      // Vérifier la réponse de l'utilisateur
      const checkAnswer = () => {
        if (!nearbyLocation) return;
        
        console.log("Réponse utilisateur:", userAnswer);
        console.log("Réponse attendue:", nearbyLocation.answer);
        
        const isCorrect = userAnswer === nearbyLocation.answer;
        
        if (isCorrect && !solvedLocations.includes(nearbyLocation.name)) {
          const updatedSolvedLocations = [...solvedLocations, nearbyLocation.name];
          setSolvedLocations(updatedSolvedLocations);
          
          // Vérifier si toutes les énigmes sont résolues
          if (updatedSolvedLocations.length === locations.length) {
            alert("Félicitations ! Vous avez résolu toutes les énigmes ! Essayez maintenant de former le mot avec les lettres obtenues.");
          } else {
            alert(`Correct ! Vous avez obtenu la lettre "${nearbyLocation.letter}". Continuez à chercher d'autres lieux !`);
          }
        } else if (isCorrect) {
          alert("Vous avez déjà résolu cette énigme !");
        } else {
          alert("Réponse incorrecte. Essayez encore !");
        }
        
        setUserAnswer('');
      };
      
      // Fonction pour traiter la résolution du mot croisé
      const handleCrosswordSolve = (letter) => {
        if (!solvedLocations.includes("Grotte")) {
          const updatedSolvedLocations = [...solvedLocations, "Grotte"];
          setSolvedLocations(updatedSolvedLocations);
          
          // Vérifier si toutes les énigmes sont résolues
          if (updatedSolvedLocations.length === locations.length) {
            alert("Félicitations ! Vous avez résolu toutes les énigmes ! Essayez maintenant de former le mot avec les lettres obtenues.");
          } else {
            alert(`Correct ! Vous avez obtenu la lettre "${letter}". Continuez à chercher d'autres lieux !`);
          }
        }
      };
      
      // Mode DEBUG pour tester toutes les questions
      const activateDebugMode = () => {
        setDebugMode(true);
        alert("MODE DEBUG ACTIVÉ ! Vous pouvez maintenant sélectionner un lieu à tester.");
      };
      
      // Sélectionner un lieu en mode DEBUG
      const selectDebugLocation = (location) => {
        setSelectedDebugLocation(location);
        setNearbyLocation(location);
        setDefaultQuestion(false);
      };

      // Vérifier le mot secret
      const checkSecretWord = () => {
        // Le mot secret est "ENIGME"
        if (secretWord.toLowerCase() === "enigme") {
          setGameCompleted(true);
        } else if (secretWord.toLowerCase() === "debug") {
          activateDebugMode();
          setSecretWord('');
        } else {
          alert("Ce n'est pas le bon mot. Continuez à chercher !");
          setSecretWord('');
        }
      };

      // Obtenir les lettres trouvées
      const getFoundLetters = () => {
        let letters = "";
        locations.forEach(location => {
          if (solvedLocations.includes(location.name)) {
            letters += location.letter;
          }
        });
        return letters;
      };

      // Affichage de la question par défaut lorsqu'on n'est pas à proximité d'un lieu
      const renderDefaultQuestion = () => {
        return (
          <div className="bg-blue-100 border border-blue-400 text-blue-700 px-4 py-3 rounded mb-4">
            <h3 className="font-bold text-lg mb-2">Question de test</h3>
            <p className="mb-2">Quel est le contraire de "froid" ?</p>
            <img 
              src="https://picsum.photos/seed/test/400/300" 
              alt="Test" 
              className="w-full h-40 object-cover rounded mb-3"
            />
            <input
              type="text"
              value={userAnswer}
              onChange={(e) => setUserAnswer(e.target.value)}
              placeholder="Votre réponse"
              className="w-full p-2 border rounded mb-2"
            />
            <button 
              onClick={() => {
                if (userAnswer.toLowerCase().trim() === "chaud") {
                  alert("Correct ! C'est juste une question de test pour vous montrer comment le jeu fonctionne.");
                } else {
                  alert("Incorrect. Essayez 'chaud'.");
                }
                setUserAnswer('');
              }}
              className="w-full bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded"
            >
              Valider
            </button>
          </div>
        );
      };

      // Page de victoire
      if (gameCompleted) {
        return (
          <div className="p-4 max-w-md mx-auto bg-white rounded-xl shadow-md overflow-hidden">
            <h2 className="text-2xl font-bold text-center text-green-800 mb-4">FÉLICITATIONS !</h2>
            <img 
              src="https://picsum.photos/seed/tresor/400/300" 
              alt="Trésor découvert" 
              className="w-full h-60 object-cover rounded mb-4"
            />
            <p className="text-center text-lg mb-4">
              Vous avez résolu l'énigme finale et trouvé le trésor !
            </p>
            <p className="text-center mb-4">
              Votre quête est maintenant terminée. Bravo pour votre perspicacité !
            </p>
            <a 
              href="https://example.com/suite" 
              target="_blank" 
              rel="noopener noreferrer" 
              className="block w-full bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded text-center"
            >
              Continuer l'aventure
            </a>
          </div>
        );
      }

      return (
        <div className="p-4 max-w-md mx-auto bg-white rounded-xl shadow-md overflow-hidden">
          <h2 className="text-xl font-bold text-gray-800 mb-4">Chasse au trésor GPS</h2>
          
          {permissionStatus === 'pending' && (
            <button 
              onClick={requestLocation}
              className="w-full bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded mb-4">
              Commencer l'aventure
            </button>
          )}
          
          {permissionStatus === 'denied' && (
            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
              L'accès à votre position a été refusé. Veuillez autoriser l'accès à votre position dans les paramètres de votre navigateur.
            </div>
          )}
          
          {permissionStatus === 'requesting' && (
            <div className="text-gray-600 mb-4">
              Demande d'accès à votre position en cours...
            </div>
          )}
          
          {error && (
            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
              {error}
            </div>
          )}
          
          {currentPosition && (
            <div className="mb-4">
              <h3 className="font-medium text-gray-700">Votre position actuelle :</h3>
              <p className="text-gray-600">
                Latitude: {currentPosition.coords.latitude.toFixed(5)}°<br />
                Longitude: {currentPosition.coords.longitude.toFixed(5)}°<br />
                Précision: ±{currentPosition.coords.accuracy.toFixed(1)} mètres
              </p>
            </div>
          )}
          
          {distance !== null && !debugMode && (
            <div className="mb-4">
              <h3 className="font-medium text-gray-700">Distance au lieu le plus proche :</h3>
              <p className="text-gray-600">
                {distance < 1000 ? 
                  `${distance.toFixed(1)} mètres` : 
                  `${(distance/1000).toFixed(2)} kilomètres`}
              </p>
            </div>
          )}
          
          {/* Interface de sélection des lieux en mode DEBUG */}
          {debugMode && (
            <div className="mt-4 p-4 bg-purple-100 rounded-lg border border-purple-300 mb-4">
              <h3 className="font-bold text-purple-800 mb-2">MODE DEBUG - Sélectionnez un lieu à tester :</h3>
              <div className="grid grid-cols-1 gap-2">
                {locations.map((location, index) => (
                  <button
                    key={index}
                    onClick={() => selectDebugLocation(location)}
                    className={`p-2 rounded ${selectedDebugLocation && selectedDebugLocation.name === location.name ? 'bg-purple-500 text-white' : 'bg-white hover:bg-purple-200'}`}
                  >
                    {location.name}
                  </button>
                ))}
              </div>
              <div className="mt-3 text-sm text-purple-800">
                <span className="font-bold">Note:</span> En mode DEBUG, vous pouvez tester toutes les questions sans vous déplacer physiquement.
              </div>
            </div>
          )}
          
          {currentPosition && defaultQuestion && !debugMode && renderDefaultQuestion()}
          
          {nearbyLocation && !defaultQuestion && (
            <div className={`${solvedLocations.includes(nearbyLocation.name) ? 'bg-green-100 border-green-400 text-green-700' : 'bg-yellow-100 border-yellow-400 text-yellow-700'} border px-4 py-3 rounded mb-4`}>
              <h3 className="font-bold">{nearbyLocation.name}</h3>
              
              {/* Affichage du mot croisé ou de la question standard selon la location */}
              {nearbyLocation.usesCrossword ? (
                solvedLocations.includes(nearbyLocation.name) ? (
                  <div className="bg-white p-3 rounded">
                    <p>Énigme résolue ! Vous avez obtenu la lettre : <span className="font-bold text-xl">{nearbyLocation.letter}</span></p>
                  </div>
                ) : (
                  <CrosswordPuzzle onSolve={handleCrosswordSolve} debugMode={debugMode} />
                )
              ) : (
                <div>
                  <p className="mb-3">{nearbyLocation.question}</p>
                  
                  {nearbyLocation.image && (
                    <img 
                      src={nearbyLocation.image} 
                      alt={nearbyLocation.name} 
                      className="w-full h-40 object-cover rounded mb-3"
                    />
                  )}
                  
                  {solvedLocations.includes(nearbyLocation.name) ? (
                    <div className="bg-white p-3 rounded">
                      <p>Énigme résolue ! Vous avez obtenu la lettre : <span className="font-bold text-xl">{nearbyLocation.letter}</span></p>
                    </div>
                  ) : (
                    <div>
                      {nearbyLocation.options && (
                        <div className="mb-3">
                          {nearbyLocation.options.map((option, idx) => (
                            <div 
                              key={idx} 
                              className={`p-2 mb-2 bg-white border rounded cursor-pointer hover:bg-yellow-50 ${userAnswer === option ? 'bg-yellow-100 border-yellow-500' : ''}`}
                              onClick={() => {
                                // Si l'option sélectionnée est exactement la réponse attendue
                                if (option === nearbyLocation.answer) {
                                  setUserAnswer(option);
                                } 
                                // Pour les cas où la réponse attendue est juste une partie de l'option
                                else if (option.includes(nearbyLocation.answer)) {
                                  setUserAnswer(nearbyLocation.answer);
                                }
                                // Sinon, sauvegarder l'option complète
                                else {
                                  setUserAnswer(option);
                                }
                              }}
                            >
                              {option}
                            </div>
                          ))}
                        </div>
                      )}
                      <input
                        type="text"
                        value={userAnswer}
                        onChange={(e) => setUserAnswer(e.target.value)}
                        placeholder="Votre réponse"
                        className="w-full p-2 border rounded mb-2"
                      />
                      <button 
                        onClick={checkAnswer}
                        className="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-medium py-2 px-4 rounded"
                      >
                        Valider
                      </button>
                    </div>
                  )}
                </div>
              )}
            </div>
          )}
          
          {/* Section pour deviner le mot secret */}
          <div className="mt-6 p-4 bg-purple-100 rounded-lg border border-purple-300">
            <h3 className="font-bold text-purple-800 mb-2">Lettres découvertes :</h3>
            <div className="flex flex-wrap gap-2 mb-4">
              {getFoundLetters().split('').map((letter, index) => (
                <div key={index} className="w-10 h-10 flex items-center justify-center bg-purple-500 text-white font-bold rounded">
                  {letter}
                </div>
              ))}
              {getFoundLetters().length === 0 && (
                <p className="text-purple-700">Aucune lettre découverte pour le moment...</p>
              )}
            </div>
            
            <h3 className="font-bold text-purple-800 mb-2">Mot secret :</h3>
            <div className="flex">
              <input
                type="text"
                value={secretWord}
                onChange={(e) => setSecretWord(e.target.value)}
                placeholder="Entrez le mot secret"
                className="flex-grow p-2 border rounded-l"
              />
              <button 
                onClick={checkSecretWord}
                className="bg-purple-500 hover:bg-purple-600 text-white font-medium py-2 px-4 rounded-r"
              >
                Vérifier
              </button>
            </div>
          </div>
          
          <div className="mt-6">
            <h3 className="font-medium text-gray-700 mb-2">Lieux d'intérêt à découvrir :</h3>
            <ul className="list-disc pl-5 text-gray-600">
              {locations.map((loc, index) => (
                <li key={index} className={solvedLocations.includes(loc.name) ? "line-through text-green-600" : ""}>
                  {loc.name}
                </li>
              ))}
            </ul>
          </div>
        </div>
      );
    };

    ReactDOM.render(<TreasureHunt />, document.getElementById('root'));
  </script>
</body>
</html>
