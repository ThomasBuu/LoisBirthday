<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ijbol quête</title>
  <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    .text-xxs {
      font-size: 0.65rem;
    }
    .overflow-x-auto::-webkit-scrollbar {
      height: 4px;
    }
    .overflow-x-auto::-webkit-scrollbar-thumb {
      background-color: rgba(156, 163, 175, 0.5);
      border-radius: 2px;
    }
    .overflow-x-auto::-webkit-scrollbar-track {
      background-color: rgba(229, 231, 235, 0.5);
    }
    @media (max-width: 640px) {
      .grid-item-small {
        width: 22px;
        height: 22px;
      }
    }
    .max-w-crossword {
      max-width: 300px;
      margin: 0 auto;
    }
    /* Animation pour cœur qui bat */
    @keyframes heartbeat {
      0% { transform: scale(1); }
      25% { transform: scale(1.1); }
      50% { transform: scale(1); }
      75% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    .heartbeat {
      animation: heartbeat 1s infinite;
      display: inline-block;
    }
    .hearts-container {
      display: flex;
      gap: 0.25rem;
    }
    /* Animation pour cœur perdu */
    @keyframes heartLost {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0.5; }
      100% { transform: scale(0); opacity: 0; }
    }
    .heart-lost {
      animation: heartLost 0.5s forwards;
    }
    /* Animation pour cœur gagné */
    @keyframes heartGained {
      0% { transform: scale(0); opacity: 0; }
      50% { transform: scale(1.5); opacity: 0.5; }
      100% { transform: scale(1); opacity: 1; }
    }
    .heart-gained {
      animation: heartGained 0.5s forwards;
    }
    /* Modal de perte de vie */
    .life-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .modal-content {
      background-color: white;
      padding: 2rem;
      border-radius: 1rem;
      text-align: center;
      max-width: 90%;
      width: 400px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
    }
    /* Style pour le bouton MAP */
    .map-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background-color: #3B82F6;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .map-button:hover {
      background-color: #2563EB;
      transform: scale(1.05);
    }
    /* Modal de carte */
    .map-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .map-modal-content {
      position: relative;
      max-width: 90%;
      max-height: 90%;
      overflow: auto;
      border-radius: 0.5rem;
      background-color: white;
    }
    .map-modal-content img {
      max-width: 100%;
      display: block;
    }
    .close-button {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(255, 255, 255, 0.8);
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
  </style>
</head>
<body class="bg-gray-100">
  <div id="root"></div>
  
  <script type="text/babel">
    // Composant de Modal pour la carte
    const MapModal = ({ onClose }) => {
      return (
        <div className="map-modal" onClick={onClose}>
          <div className="map-modal-content" onClick={(e) => e.stopPropagation()}>
            <img src="images/map.png" alt="Carte du trésor" />
            <div className="close-button" onClick={onClose}>×</div>
          </div>
        </div>
      );
    };
    
    // Composant de mot croisé
    const CrosswordPuzzle = ({ onSolve, onWrongAnswer, debugMode }) => {
      const [userAnswers, setUserAnswers] = React.useState([]);
      const [isSolved, setIsSolved] = React.useState(false);
      const [gridData, setGridData] = React.useState(null);
      const [focusedCell, setFocusedCell] = React.useState(null);
      const [error, setError] = React.useState(null);
      const [attemptsLeft, setAttemptsLeft] = React.useState(3); // On donne 3 essais pour le mot croisé
      
      // Initialisation de la grille
      React.useEffect(() => {
        try {
          // Données de la grille de mots croisés
          const data = {
            "grid": [
              [
                { "type": "black" }, { "type": "black" }, { "type": "white", "number": 1 }, { "type": "black" }, { "type": "black" }, 
                { "type": "white", "number": 2 }, { "type": "black" }, { "type": "white", "number": 3 }, { "type": "white" }, 
                { "type": "white", "number": 4 }, { "type": "black" }, { "type": "black" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "white" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "white" }, 
                { "type": "black" }, { "type": "black" }
              ],
              [
                { "type": "white", "number": 5 }, { "type": "white" }, { "type": "white" }, { "type": "white" }, { "type": "white" }, 
                { "type": "red" }, { "type": "white" }, { "type": "white" }, { "type": "black" }, { "type": "white" }, 
                { "type": "black" }, { "type": "black" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "white" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "white" }, 
                { "type": "black" }, { "type": "black" }
              ],
              [
                { "type": "white", "number": 6 }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "white" }, { "type": "black" }, { "type": "white", "number": 7 }, { "type": "black" }, { "type": "white" }, 
                { "type": "black" }, { "type": "black" }
              ],
              [
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "white", "number": 8 }, 
                { "type": "white" }, { "type": "white" }, { "type": "white" }, { "type": "white" }, { "type": "white" }, 
                { "type": "white"}, { "type": "white" , "number": 9 }
              ],
              [
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "white", "number": 10 }, { "type": "white" }, { "type": "white" }, { "type": "white" }, { "type": "white" }, 
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white", "number": 11 }, { "type": "white" }, { "type": "white" }, { "type": "white" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ]
            ],
            "clues": {
              "across": [
                { "number": 3, "clue": "Album préféré de Loïs" },
                { "number": 5, "clue": "Ville et couleur" },
                { "number": 8, "clue": "Vrai prénom de Dan" },
                { "number": 10, "clue": "Animal préféré de Loïs" },
                { "number": 11, "clue": "Dans quelle ville est NÉ Loïs" }
              ],
              "down": [
                { "number": 1, "clue": "Film d'horreur/slasher pref de Loïs" },
                { "number": 2, "clue": "Alcool préféré de Loïs" },
                { "number": 4, "clue": "i m not a drag queen I m the queen of drag" },
                { "number": 6, "clue": "Taylor" },
                { "number": 7, "clue": "macaque tibétain manchot" },
                { "number": 9, "clue": "Boutique ou Loïs travaille" }
              ]
            }
          };
          
          // Initialiser les tableaux pour les réponses utilisateur
          const emptyAnswers = data.grid.map(row => 
            row.map(cell => cell.type === "white" ? "" : null)
          );
          
          setGridData(data);
          setUserAnswers(emptyAnswers);
        } catch (err) {
          setError("Erreur lors du chargement des données: " + err.message);
        }
      }, []);
      
      // Solutions attendues avec les tailles correctes
      const expectedSolutions = {
        "across": {
          3: "nfr",
          5: "bordeaux",
          8: "danielle",
          10: "tortue",
          11: "nice"
        },
        "down": {
          1: "terrifier",
          2: "champagne",
          4: "rupaul",
          6: "swift",
          7: "xingxing",
          9: "ethereal"
        }
      };
      
      // Fonction pour remplir automatiquement une réponse (triche)
      const fillAnswer = (direction, number) => {
        // Obtenir la solution attendue
        const solution = expectedSolutions[direction][number];
        if (!solution) return;
        
        // Trouver la position de départ
        let startPos = null;
        for (let i = 0; i < gridData.grid.length; i++) {
          for (let j = 0; j < gridData.grid[i].length; j++) {
            if (gridData.grid[i][j].type === "white" && 
                gridData.grid[i][j].number === number) {
              startPos = { row: i, col: j };
              break;
            }
          }
          if (startPos) break;
        }
        
        if (!startPos) return;
        
        // Créer une copie des réponses actuelles
        const newAnswers = [...userAnswers];
        
        // Remplir les cases selon la direction
        if (direction === "across") {
          // Horizontal (de gauche à droite)
          for (let i = 0; i < solution.length; i++) {
            const col = startPos.col + i;
            if (col < gridData.grid[startPos.row].length && 
                gridData.grid[startPos.row][col].type === "white") {
              newAnswers[startPos.row][col] = solution[i];
            }
          }
        } else if (direction === "down") {
          // Vertical (de haut en bas)
          for (let i = 0; i < solution.length; i++) {
            const row = startPos.row + i;
            if (row < gridData.grid.length && 
                gridData.grid[row] && 
                gridData.grid[row][startPos.col] && 
                gridData.grid[row][startPos.col].type === "white") {
              newAnswers[row][startPos.col] = solution[i];
            }
          }
        }
        
        setUserAnswers(newAnswers);
      };
      
      // Remplir toute la grille en un clic (bouton "Triche complète")
      const fillAllAnswers = () => {
        // Remplir d'abord les mots horizontaux
        Object.keys(expectedSolutions.across).forEach(number => {
          fillAnswer("across", parseInt(number));
        });
        
        // Puis les mots verticaux
        Object.keys(expectedSolutions.down).forEach(number => {
          fillAnswer("down", parseInt(number));
        });
        
        // Vérifier automatiquement après remplissage complet
        setTimeout(() => checkSolution(), 300);
      };
      

      // Modification du composant CrosswordPuzzle pour ajouter la fonctionnalité de la case rouge

      // Mettre à jour la fonction handleInputChange pour gérer le cas spécial
      const handleInputChange = (rowIndex, colIndex, value) => {
        // Accepter uniquement une lettre
        if (value.length > 1) {
          value = value.charAt(value.length - 1);
        }
        
        // Convertir en majuscule
        value = value.toUpperCase();
        
        // Mettre à jour les réponses de l'utilisateur
        const newAnswers = [...userAnswers];
        newAnswers[rowIndex][colIndex] = value;
        setUserAnswers(newAnswers);
        
        // Si une lettre a été saisie, déplacer le focus vers la cellule suivante
        // Seulement si on n'est pas en mode dernière chance (où on ne remplit qu'une case)
        if (value !== "" && attemptsLeft > 0) {
          moveToNextCell(rowIndex, colIndex);
        }
      };

      
      // Fonction pour gérer la touche Backspace et les flèches
      const handleKeyDown = (e, rowIndex, colIndex) => {
        if (e.key === "Backspace" && userAnswers[rowIndex][colIndex] === "") {
          e.preventDefault();
          moveToPrevCell(rowIndex, colIndex);
        } else if (e.key === "ArrowRight") {
          e.preventDefault();
          moveHorizontal(rowIndex, colIndex, 1);
        } else if (e.key === "ArrowLeft") {
          e.preventDefault();
          moveHorizontal(rowIndex, colIndex, -1);
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          moveVertical(rowIndex, colIndex, -1);
        } else if (e.key === "ArrowDown") {
          e.preventDefault();
          moveVertical(rowIndex, colIndex, 1);
        }
      };
      
      // Déplacer vers la cellule suivante (horizontalement)
      const moveToNextCell = (rowIndex, colIndex) => {
        // Essayer de trouver la prochaine cellule blanche horizontalement
        let nextCol = colIndex + 1;
        while (nextCol < gridData.grid[rowIndex].length) {
          if (gridData.grid[rowIndex][nextCol].type === "white") {
            focusCell(rowIndex, nextCol);
            return;
          }
          nextCol++;
        }
        
        // Si pas trouvé, essayer la ligne suivante
        let nextRow = rowIndex + 1;
        while (nextRow < gridData.grid.length) {
          for (let col = 0; col < gridData.grid[nextRow].length; col++) {
            if (gridData.grid[nextRow][col].type === "white") {
              focusCell(nextRow, col);
              return;
            }
          }
          nextRow++;
        }
      };
      
      // Déplacer vers la cellule précédente
      const moveToPrevCell = (rowIndex, colIndex) => {
        let prevCol = colIndex - 1;
        while (prevCol >= 0) {
          if (gridData.grid[rowIndex][prevCol].type === "white") {
            focusCell(rowIndex, prevCol);
            return;
          }
          prevCol--;
        }
        
        // Si pas trouvé, essayer la ligne précédente
        let prevRow = rowIndex - 1;
        while (prevRow >= 0) {
          for (let col = gridData.grid[prevRow].length - 1; col >= 0; col--) {
            if (gridData.grid[prevRow][col].type === "white") {
              focusCell(prevRow, col);
              return;
            }
          }
          prevRow--;
        }
      };
      
      // Déplacer horizontalement
      const moveHorizontal = (rowIndex, colIndex, direction) => {
        let nextCol = colIndex + direction;
        while (nextCol >= 0 && nextCol < gridData.grid[rowIndex].length) {
          if (gridData.grid[rowIndex][nextCol].type === "white") {
            focusCell(rowIndex, nextCol);
            return;
          }
          nextCol += direction;
        }
      };
      
      // Déplacer verticalement
      const moveVertical = (rowIndex, colIndex, direction) => {
        let nextRow = rowIndex + direction;
        while (nextRow >= 0 && nextRow < gridData.grid.length) {
          if (gridData.grid[nextRow][colIndex].type === "white") {
            focusCell(nextRow, colIndex);
            return;
          }
          nextRow += direction;
        }
      };
      
      // Mettre le focus sur une cellule
      const focusCell = (rowIndex, colIndex) => {
        setFocusedCell({ row: rowIndex, col: colIndex });
        
        setTimeout(() => {
          const input = document.getElementById(`cell-${rowIndex}-${colIndex}`);
          if (input) {
            input.focus();
          }
        }, 0);
      };
      
      // Vérifier si le mot croisé est correctement rempli
      // Modifier la fonction checkSolution pour gérer le cas spécial de la case rouge
      const checkSolution = () => {
        // Si plus d'essais, on vérifie uniquement la case rouge
        if (attemptsLeft === 0) {
          // Trouver la position de la case rouge
          let redCellPosition = null;
          for (let i = 0; i < gridData.grid.length; i++) {
            for (let j = 0; j < gridData.grid[i].length; j++) {
              if (gridData.grid[i][j].type === "red") {
                redCellPosition = { row: i, col: j };
                break;
              }
            }
            if (redCellPosition) break;
          }
          
          // Vérifier si la lettre dans la case rouge est correcte (devrait être "A")
          if (redCellPosition && userAnswers[redCellPosition.row][redCellPosition.col] === "A") {
            setIsSolved(true);
            if (onSolve) {
              onSolve("A");
            }
          } else {
            // Perdre une vie UNIQUEMENT ici, si la solution de la case rouge n'est pas correcte
            if (onWrongAnswer) {
              onWrongAnswer();
            }
            alert("Réponse incorrecte pour la case rouge. Vous perdez une vie !");
          }
          return;
        }
        
        // Logique originale pour les essais normaux
        // Pour faciliter les tests, considérer comme correct si au moins 70% des lettres sont saisies
        let filledCells = 0;
        let totalCells = 0;
        
        // Compter les cellules remplies
        for (let i = 0; i < gridData.grid.length; i++) {
          for (let j = 0; j < gridData.grid[i].length; j++) {
            if (gridData.grid[i][j].type === "white" || gridData.grid[i][j].type === "red") {
              totalCells++;
              if (userAnswers[i][j] && userAnswers[i][j] !== "") {
                filledCells++;
              }
            }
          }
        }
        
        // Calculer le pourcentage de remplissage
        const fillPercentage = (filledCells / totalCells) * 100;
        
        // Si au moins 70% des cellules sont remplies, considérer comme résolu
        if (fillPercentage >= 70) {
          setIsSolved(true);
          if (onSolve) {
            onSolve("A"); // Retourne la lettre "A" correspondant à l'énigme de la grotte
          }
        } else {
          // Réduire le nombre d'essais sans perdre de vie
          if (attemptsLeft > 0) {
            setAttemptsLeft(attemptsLeft - 1);
            // Ne PAS appeler onWrongAnswer ici pour éviter de perdre une vie pendant les 3 essais
            alert(`La grille est remplie à ${Math.round(fillPercentage)}%, il faut au moins 70% pour valider. Il vous reste ${attemptsLeft - 1} essai(s).`);
            
            // Si c'était le dernier essai, ajouter un message supplémentaire
            if (attemptsLeft - 1 === 0) {
              setTimeout(() => {
                alert("Vous pouvez maintenant essayer de deviner uniquement la lettre dans la case rouge. Attention: une erreur vous fera perdre une vie!");
              }, 500);
            }
          } else {
            alert("Vous n'avez plus d'essais disponibles. Essayez de trouver la lettre dans la case rouge!");
          }
        }
      };
      
      // Si les données ne sont pas encore chargées
      if (!gridData) {
        return <div>Chargement du mot croisé...</div>;
      }
      
      // Si une erreur est survenue
      if (error) {
        return <div className="text-red-600">{error}</div>;
      }
      
      return (
        <div className="p-4 bg-white rounded-xl shadow">
          <h3 className="text-xl font-bold mb-4">Mot Croisé - La Grotte</h3>
          
          {isSolved ? (
            <div className="bg-green-100 p-4 rounded text-green-800 mb-4">
              <p className="font-bold">Bravo ! Vous avez résolu le mot croisé.</p>
              <p>Vous avez obtenu la lettre : <span className="text-2xl font-bold">A</span></p>
            </div>
          ) : (
            <div className="mb-4">
              <p className="text-gray-700 mb-2">
                Remplissez le mot croisé pour débloquer l'indice de la grotte.
                Si vous ne trouvez pas tout, la lettre qui croise le 5 et le 2 est la solution  
              </p>
              <div className="flex justify-between items-center mb-2">
                <span className="text-sm text-gray-600">Essais restants: {attemptsLeft}</span>
                {debugMode && (
                  <button 
                    onClick={fillAllAnswers}
                    className="mt-2 bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-2 rounded text-sm"
                  >
                    Triche complète
                  </button>
                )}
              </div>
            </div>
          )}
          
          <div className="flex flex-col gap-4">
            {/* Grille de mot croisé */}
          <div className="w-full overflow-x-auto pb-2">
            <div className="max-w-crossword">
              <div 
                className="grid gap-px bg-gray-300 inline-block mx-auto"
                style={{ 
                  gridTemplateRows: `repeat(${gridData.grid.length}, 25px)`,
                  gridTemplateColumns: `repeat(${gridData.grid[0].length}, 25px)`
                }}
              >
                {gridData.grid.map((row, rowIndex) => (
                  row.map((cell, colIndex) => (
                    <div
                      key={`${rowIndex}-${colIndex}`}
                      className={`relative flex items-center justify-center grid-item-small
                        ${cell.type === "black" ? "bg-black" : 
                          cell.type === "red" && attemptsLeft === 0 ? "bg-red-300" : 
                          cell.type === "red" ? "bg-white" : "bg-white"}
                        ${focusedCell && focusedCell.row === rowIndex && focusedCell.col === colIndex 
                          ? "ring-1 ring-blue-500" : ""}
                      `}
                      onClick={() => (cell.type === "white" || cell.type === "red") && focusCell(rowIndex, colIndex)}
                    >
                      {(cell.type === "white" || cell.type === "red") && cell.number && (
                        <span className="absolute top-0 left-0.5 text-xxs md:text-xs font-semibold text-gray-500">
                          {cell.number}
                        </span>
                      )}
                      
                      {(cell.type === "white" || cell.type === "red") && (
                        <input
                          id={`cell-${rowIndex}-${colIndex}`}
                          type="text"
                          maxLength="1"
                          className="w-full h-full text-center font-bold uppercase bg-transparent outline-none text-xs md:text-base"
                          value={userAnswers[rowIndex] && userAnswers[rowIndex][colIndex] ? userAnswers[rowIndex][colIndex] : ""}
                          onChange={(e) => handleInputChange(rowIndex, colIndex, e.target.value)}
                          onKeyDown={(e) => handleKeyDown(e, rowIndex, colIndex)}
                          disabled={isSolved || (attemptsLeft === 0 && cell.type !== "red")}
                        />
                      )}
                    </div>
                  ))
                ))}
              </div>
              
              {!isSolved && (
                <button 
                  onClick={checkSolution}
                  className={`mt-4 w-full ${attemptsLeft === 0 ? 'bg-red-500 hover:bg-red-600' : 'bg-blue-500 hover:bg-blue-600'} text-white font-bold py-2 px-4 rounded`}
                >
                  {attemptsLeft === 0 ? "Vérifier la case rouge" : "Vérifier la solution"}
                </button>
              )}
              
              {!isSolved && attemptsLeft === 0 && (
                <div className="mt-4 bg-red-100 p-3 rounded border border-red-300 text-red-700 text-center">
                  <p>Plus d'essais disponibles! Trouvez la lettre dans la case rouge (maintenant colorée). Attention: une erreur vous fera perdre une vie!</p>
                </div>
              )}
            </div>
          </div>
            
            {/* Indices */}
            <div className="w-full">
              <div className="bg-gray-100 p-4 rounded">
                <div className="mb-4">
                  <h4 className="font-bold text-lg mb-2">Horizontalement</h4>
                  <ul className="space-y-2">
                    {gridData.clues.across.map((clue) => (
                      <li key={`across-${clue.number}`} className="flex items-center">
                        <span className="font-semibold mr-1">{clue.number}.</span> {clue.clue}
                        {debugMode && !isSolved && (
                          <button 
                            onClick={() => fillAnswer("across", clue.number)}
                            className="ml-2 bg-red-500 hover:bg-red-600 text-white font-bold py-0.5 px-1 rounded text-xs"
                          >
                            Triche
                          </button>
                        )}
                      </li>
                    ))}
                  </ul>
                </div>
                
                <div>
                  <h4 className="font-bold text-lg mb-2">Verticalement</h4>
                  <ul className="space-y-2">
                    {gridData.clues.down.map((clue) => (
                      <li key={`down-${clue.number}`} className="flex items-center">
                        <span className="font-semibold mr-1">{clue.number}.</span> {clue.clue}
                        {debugMode && !isSolved && (
                          <button 
                            onClick={() => fillAnswer("down", clue.number)}
                            className="ml-2 bg-red-500 hover:bg-red-600 text-white font-bold py-0.5 px-1 rounded text-xs"
                          >
                            Triche
                          </button>
                        )}
                      </li>
                    ))}
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    // Composant modal pour envoyer un compliment
    const ComplimentModal = ({ onClose, onLifeGained }) => {
      const compliments = [
        "Loïs, tu es vraiment l'esprit le plus brillant que je connaisse et un ami hors pair.",
        "Loïs, ta bienveillance illumine chaque instant et rend la vie plus douce.",
        "Loïs, j'admire ta sagesse et ta loyauté : tu es un trésor d'amitié.",
        "Loïs, ta présence transforme les pires journées en moments magiques.",
        "Loïs, tu as un cœur en or et ta générosité n'a d'égale que ta joie de vivre.",
        "Loïs, tu es l'exemple parfait d'un ami fidèle sur qui on peut toujours compter.",
        "Loïs, ta créativité et ton empathie font de toi un allié incomparable.",
        "Loïs, ton intelligence et ton humour font de chaque conversation un pur bonheur.",
        "Loïs, ta force tranquille et ton soutien sont un cadeau pour ceux qui t'entourent.",
        "Loïs, tu incarnes l'amitié idéale : sincère, généreuse et inspirante."
      ];
      
      const sendCompliment = () => {
        // Choix aléatoire
        const randomIndex = Math.floor(Math.random() * compliments.length);
        const message = compliments[randomIndex];
        
        // Envoyer le SMS
        window.location.href = `sms:+33634481088?body=${encodeURIComponent(message)}`;
        
        // Notifier que la vie est gagnée
        setTimeout(() => {
          onLifeGained();
          onClose();
        }, 500);
      };
      
      return (
        <div className="life-modal">
          <div className="modal-content">
            <h3 className="text-xl font-bold mb-4">Regagner une vie ❤️</h3>
            <p className="mb-4">Envoie un compliment à Loïs pour regagner une vie et continuer l'aventure !</p>
            
            <div className="flex space-x-2 justify-center mb-4">
              <button 
                onClick={sendCompliment}
                className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition"
              >
                Envoyer un compliment
              </button>
              <button 
                onClick={onClose}
                className="px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 transition"
              >
                Annuler
              </button>
            </div>
            
            <p className="text-xs text-gray-500">
              Un SMS sera automatiquement préparé avec un compliment aléatoire. Tu n'auras plus qu'à l'envoyer !
            </p>
          </div>
        </div>
      );
    };

    // Application principale de chasse au trésor
    const TreasureHunt = () => {
      const [currentPosition, setCurrentPosition] = React.useState(null);
      const [nearbyLocation, setNearbyLocation] = React.useState(null);
      const [error, setError] = React.useState(null);
      const [distance, setDistance] = React.useState(null);
      const [permissionStatus, setPermissionStatus] = React.useState('pending');
      const [userAnswer, setUserAnswer] = React.useState('');
      const [solvedLocations, setSolvedLocations] = React.useState([]);
      const [secretWord, setSecretWord] = React.useState('');
      const [debugMode, setDebugMode] = React.useState(false);
      const [selectedDebugLocation, setSelectedDebugLocation] = React.useState(null);
      const [lives, setLives] = React.useState(3); // Vies par défaut
      const [showComplimentModal, setShowComplimentModal] = React.useState(false);
      const [showLifeLostModal, setShowLifeLostModal] = React.useState(false);
      const [showMapModal, setShowMapModal] = React.useState(false); // État pour la modale de carte
      const [startTime, setStartTime] = React.useState(null);  // Heure de début
      const [elapsedTime, setElapsedTime] = React.useState(0); // Temps écoulé
      const [watchId, setWatchId] = React.useState(null);      // ID du watcher de géolocalisation

      // Charger les données depuis les cookies au démarrage
      React.useEffect(() => {
        const savedLocations = localStorage.getItem('solvedLocations');
        if (savedLocations) {
          setSolvedLocations(JSON.parse(savedLocations));
        }
        
        // Charger le nombre de vies depuis les cookies
        const savedLives = getCookie('lives');
        if (savedLives) {
          setLives(parseInt(savedLives));
        } else {
          // Si pas de cookie, initialiser à 3 vies
          setCookie('lives', 3, 7); // Expire dans 7 jours
        }
        
        // Charger le temps de départ depuis les cookies
        const savedStartTime = getCookie('startTime');
        if (savedStartTime) {
          setStartTime(parseInt(savedStartTime));
          setPermissionStatus('granted');
          requestLocation(); // Redemander la géolocalisation si on a déjà commencé
        }
      }, []);

      // Sauvegarder les données dans localStorage à chaque mise à jour
      React.useEffect(() => {
        if (solvedLocations.length > 0) {
          localStorage.setItem('solvedLocations', JSON.stringify(solvedLocations));
        }
      }, [solvedLocations]);
      
      // Sauvegarder les vies dans les cookies à chaque mise à jour
      React.useEffect(() => {
        setCookie('lives', lives, 7); // Expire dans 7 jours
      }, [lives]);
      
      // Effet pour mettre à jour le chronomètre chaque seconde
      React.useEffect(() => {
        if (startTime) {
          const intervalId = setInterval(() => {
            const now = Date.now();
            const elapsed = Math.floor((now - startTime) / 1000); // Temps écoulé en secondes
            setElapsedTime(elapsed);
          }, 1000);
          
          return () => clearInterval(intervalId);
        }
      }, [startTime]);
      
      // Fonctions pour gérer les cookies
      const setCookie = (name, value, days) => {
        let expires = "";
        if (days) {
          const date = new Date();
          date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
          expires = "; expires=" + date.toUTCString();
        }
        document.cookie = name + "=" + value + expires + "; path=/";
      };
      
      const getCookie = (name) => {
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++) {
          let c = ca[i];
          while (c.charAt(0) === ' ') c = c.substring(1, c.length);
          if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
      };
      
      // Fonction pour démarrer le chronomètre
      const startTimer = () => {
        // Vérifier si un chronomètre existe déjà dans les cookies
        const savedStartTime = getCookie('startTime');
        
        if (savedStartTime) {
          setStartTime(parseInt(savedStartTime));
        } else {
          const now = Date.now();
          setStartTime(now);
          setCookie('startTime', now.toString(), 7); // 7 jours d'expiration
        }
      };
      
      // Formater le temps en heures:minutes:secondes
      const formatTime = (timeInSeconds) => {
        const hours = Math.floor(timeInSeconds / 3600);
        const minutes = Math.floor((timeInSeconds % 3600) / 60);
        const seconds = timeInSeconds % 60;
        
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      };
      
      // Fonction pour perdre une vie
      const loseLife = () => {
        if (lives > 0) {
          setLives(lives - 1);
          setShowLifeLostModal(true);
          
          // Fermer la modal après 2 secondes
          setTimeout(() => {
            setShowLifeLostModal(false);
          }, 2000);
        }
      };
      
      // Fonction pour gagner une vie
      const gainLife = () => {
        setLives(lives + 1);
      };
      
      // Liste des lieux avec les lettres modifiées pour former "PARIS"
      const locations = [
        { 
          name: "Barques", 
          lat: 48.83300, 
          lng: 2.40986, 
          question: "Combien Loïs va-t-il payer individuellement si il va faire de la barque au lac de Dausmenil avec Luna pendant 3heures ?", 
          options: [
            "37,00€",
            "39,50€",
            "47,40€",
            "79,00€"
          ],
          answer: "39,50", 
          letter: "S", // Modifié: E → S
          image: "images/barque.png" // Utilisation de l'image locale
        },
        { 
          name: "Île des paons", 
          lat: 48.83105, 
          lng: 2.41189, 
          question: "Quel oiseau ne trouve-t-on pas sur le lac de daumesnil ?", 
          options: [
            "Oie de Guinée",
            "Canard colvert",
            "Foulque",
            "Cygne"
          ],
          answer: "Oie de Guinée", 
          letter: "R", // Modifié: N → R
          image: "images/ile.png" // Utilisation de l'image locale
        },
        { 
          name: "Grotte", 
          lat: 48.83003, 
          lng: 2.41575,
          usesCrossword: true, // Paramètre pour indiquer qu'on utilise un mot croisé
          question: "Complétez le mot croisé pour obtenir la lettre", 
          answer: "", // Pas besoin de réponse car géré par le composant de mot croisé
          letter: "A", // Modifié: I → A
          image: "images/grotte.png" // Utilisation de l'image locale
        },
        { 
          name: "Pèlerins des nuages et de l'eau", 
          lat: 48.82903, 
          lng: 2.41375, 
          question: "Dans un aquarium il y a 10 poissons rouges. 2 se sont noyés, 4 nagent entre les rochers et 3 sont morts. Combien de poissons rouges reste-t-il ?", 
          options: [
            "4",
            "5",
            "7",
            "10"
          ],
          answer: "10", 
          letter: "P", // Modifié: G → P
          image: "images/statue.png" // Utilisation de l'image locale
        },
        { 
          name: "Pont sud", 
          lat: 48.82845, 
          lng: 2.41837, 
          question: "L'île de Bercy est-elle un île artificielle ? Si oui en quelle année a-t-elle été créée ?", 
          options: [
            "Ce n'est pas une île artificielle mais elle a été découverte transformée en parc en 1690",
            "Ce n'est pas une île artificielle mais elle a été découverte transformée en parc en 1960",
            "Oui en 1960",
            "Oui en 1860"
          ],
          answer: "Oui en 1860", 
          letter: "I", // Modifié: M → I
          image: "images/pont.png" // Utilisation de l'image locale
        }
      ];

      // Fonction pour calculer la distance entre deux points GPS (formule de Haversine)
      const calculateDistance = (lat1, lon1, lat2, lon2) => {
        const R = 6371000; // Rayon de la Terre en mètres
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = 
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      };

      // Fonction pour vérifier la proximité des lieux
      const checkProximity = (position) => {
        if (!position) return;
        
        const { latitude, longitude } = position.coords;
        
        // Ne pas vérifier la proximité si nous sommes en mode debug et qu'un lieu est sélectionné
        if (debugMode && selectedDebugLocation) {
          return;
        }
        
        // Trouver le lieu le plus proche
        let closestLocation = null;
        let minDistance = Infinity;
        
        locations.forEach(location => {
          const dist = calculateDistance(latitude, longitude, location.lat, location.lng);
          if (dist < minDistance) {
            minDistance = dist;
            closestLocation = { ...location, distance: dist };
          }
        });
        
        setDistance(minDistance);
        
        // Considérer comme "proche" si moins de 100 mètres
        if (minDistance < 100) {
          setNearbyLocation(closestLocation);
        } else {
          setNearbyLocation(null);
        }
      };
      
            // Fonction pour supprimer tous les cookies et données locales
      const resetAllData = () => {
        // Supprimer tous les cookies
        document.cookie.split(";").forEach(function(c) {
          document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
        });
        
        // Supprimer les données de localStorage
        localStorage.removeItem('solvedLocations');
        
        // Alerter l'utilisateur
        alert("Toutes les données ont été réinitialisées. La page va être rechargée.");
        
        // Recharger la page
        window.location.reload();
      };
      
      // Demander la géolocalisation
      const requestLocation = () => {
        setPermissionStatus('requesting');
        
        if (!navigator.geolocation) {
          setError("La géolocalisation n'est pas supportée par votre navigateur");
          setPermissionStatus('denied');
          return;
        }
        
        // Démarrer le chronomètre
        startTimer();
        
        navigator.geolocation.getCurrentPosition(
          (position) => {
            setCurrentPosition(position);
            checkProximity(position);
            setPermissionStatus('granted');
            
            // Mettre à jour la position régulièrement
            const id = navigator.geolocation.watchPosition(
              (newPosition) => {
                setCurrentPosition(newPosition);
                checkProximity(newPosition);
              },
              (err) => {
                setError(`Erreur: ${err.message}`);
                setPermissionStatus('error');
              }
            );
            
            setWatchId(id);
          },
          (err) => {
            if (err.code === 1) { // PERMISSION_DENIED
              setPermissionStatus('denied');
            }
            setError(`Erreur: ${err.message}`);
          },
          { enableHighAccuracy: true }
        );
      };

      // Vérifier la réponse de l'utilisateur
      const checkAnswer = () => {
        if (!nearbyLocation || lives <= 0) return;
        
        const isCorrect = userAnswer === nearbyLocation.answer;
        
        if (isCorrect && !solvedLocations.includes(nearbyLocation.name)) {
          const updatedSolvedLocations = [...solvedLocations, nearbyLocation.name];
          setSolvedLocations(updatedSolvedLocations);
          
          // Vérifier si toutes les énigmes sont résolues
          if (updatedSolvedLocations.length === locations.length) {
            alert("Félicitations ! Vous avez résolu toutes les énigmes ! Essayez maintenant de former le mot avec les lettres obtenues.");
          } else {
            alert(`Correct ! Vous avez obtenu la lettre "${nearbyLocation.letter}". Continuez à chercher d'autres lieux !`);
          }
        } else if (isCorrect) {
          alert("Vous avez déjà résolu cette énigme !");
        } else {
          // Perdre une vie si la réponse est incorrecte
          loseLife();
          alert("Réponse incorrecte. Vous perdez une vie !");
        }
        
        setUserAnswer('');
      };
      
      // Fonction pour traiter la résolution du mot croisé
      const handleCrosswordSolve = (letter) => {
        if (!solvedLocations.includes("Grotte")) {
          const updatedSolvedLocations = [...solvedLocations, "Grotte"];
          setSolvedLocations(updatedSolvedLocations);
          
          // Vérifier si toutes les énigmes sont résolues
          if (updatedSolvedLocations.length === locations.length) {
            alert("Félicitations ! Vous avez résolu toutes les énigmes ! Essayez maintenant de former le mot avec les lettres obtenues.");
          } else {
            alert(`Correct ! Vous avez obtenu la lettre "${letter}". Continuez à chercher d'autres lieux !`);
          }
        }
      };
      
      // Mode DEBUG pour tester toutes les questions
      const activateDebugMode = () => {
        setDebugMode(true);
        alert("MODE DEBUG ACTIVÉ ! Vous pouvez maintenant sélectionner un lieu à tester et ajouter des vies.");
      };
      
      // Sélectionner un lieu en mode DEBUG
      const selectDebugLocation = (location) => {
        setSelectedDebugLocation(location);
        setNearbyLocation(location);
        // Désactiver temporairement la surveillance GPS pour éviter les interférences
        if (watchId) {
          navigator.geolocation.clearWatch(watchId);
          setWatchId(null);
        }
      };

      // Vérifier le mot secret
      // Modification de la fonction checkSecretWord existante
      const checkSecretWord = () => {
        // Le mot secret est "PARIS"
        if (secretWord.toLowerCase() === "paris") {
          window.location.href = "index2.html"; // Redirection vers la page de célébration
        } else if (secretWord.toLowerCase() === "debug") {
          activateDebugMode();
          setSecretWord('');
        } else if (secretWord.toUpperCase() === "RESETALL") {
          // Nouveau cas pour réinitialiser les données
          resetAllData();
        } else {
          // Perdre une vie pour mauvaise tentative
          loseLife();
          alert("Ce n'est pas le bon mot. Vous perdez une vie !");
          setSecretWord('');
        }
      };

      // Obtenir les lettres trouvées
      const getFoundLetters = () => {
        let letters = "";
        locations.forEach(location => {
          if (solvedLocations.includes(location.name)) {
            letters += location.letter;
          }
        });
        return letters;
      };

      // Rendu du composant principal
      return (
        <div className="p-4 max-w-md mx-auto bg-white rounded-xl shadow-md overflow-hidden relative">
          {/* Bouton MAP */}
          <div 
            className="map-button"
            onClick={() => setShowMapModal(true)}
          >
            MAP
          </div>

          {/* Modale de carte */}
          {showMapModal && (
            <MapModal onClose={() => setShowMapModal(false)} />
          )}
          
          {/* Barre de vie */}
          <div className="absolute top-2 right-2 flex items-center">
            <div className="hearts-container mr-2">
              {Array.from({ length: lives }).map((_, i) => (
                <span key={i} className="text-red-500 text-xl heartbeat">❤️</span>
              ))}
              {Array.from({ length: Math.max(0, 5 - lives) }).map((_, i) => (
                <span key={i} className="text-gray-300 text-xl">🖤</span>
              ))}
            </div>
            <button 
              onClick={() => setShowComplimentModal(true)}
              className="bg-pink-500 hover:bg-pink-600 text-white text-xs rounded-full p-1"
              title="Gagner une vie"
            >
              +
            </button>
            {debugMode && (
              <button 
                onClick={() => setLives(Math.min(5, lives + 1))}
                className="ml-1 bg-purple-500 hover:bg-purple-600 text-white text-xs rounded-full p-1"
                title="DEBUG: Ajouter une vie"
              >
                +D
              </button>
            )}
          </div>
          
          <h2 className="text-xl font-bold text-gray-800 mb-4">ijbol quête</h2>
          
          {/* Affichage du chronomètre */}
          <div className="flex items-center justify-between mb-4">
            {startTime && (
              <div className="text-gray-600 font-mono">
                <span className="font-medium">Temps écoulé:</span> {formatTime(elapsedTime)}
              </div>
            )}
          </div>
          
          {permissionStatus === 'pending' && (
            <button 
              onClick={requestLocation}
              className="w-full bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded mb-4">
              Commencer l'aventure
            </button>
          )}
          
          {permissionStatus === 'denied' && (
            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
              L'accès à votre position a été refusé. Veuillez autoriser l'accès à votre position dans les paramètres de votre navigateur.
            </div>
          )}
          
          {permissionStatus === 'requesting' && (
            <div className="text-gray-600 mb-4">
              Demande d'accès à votre position en cours...
            </div>
          )}
          
          {error && (
            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
              {error}
            </div>
          )}
          
          {currentPosition && (
            <div className="mb-4">
              <h3 className="font-medium text-gray-700">Votre position actuelle :</h3>
              <p className="text-gray-600">
                Latitude: {currentPosition.coords.latitude.toFixed(5)}°<br />
                Longitude: {currentPosition.coords.longitude.toFixed(5)}°<br />
                Précision: ±{currentPosition.coords.accuracy.toFixed(1)} mètres
              </p>
            </div>
          )}
          
          {distance !== null && !debugMode && (
            <div className="mb-4">
              <h3 className="font-medium text-gray-700">Distance au lieu le plus proche :</h3>
              <p className="text-gray-600">
                {distance < 1000 ? 
                  `${distance.toFixed(1)} mètres` : 
                  `${(distance/1000).toFixed(2)} kilomètres`}
              </p>
            </div>
          )}
          
          {/* Interface de sélection des lieux en mode DEBUG */}
          {debugMode && (
            <div className="mt-4 p-4 bg-purple-100 rounded-lg border border-purple-300 mb-4">
              <h3 className="font-bold text-purple-800 mb-2">MODE DEBUG - Sélectionnez un lieu à tester :</h3>
              <div className="grid grid-cols-1 gap-2">
                {locations.map((location, index) => (
                  <button
                    key={index}
                    onClick={() => selectDebugLocation(location)}
                    className={`p-2 rounded ${selectedDebugLocation && selectedDebugLocation.name === location.name ? 'bg-purple-500 text-white' : 'bg-white hover:bg-purple-200'}`}
                  >
                    {location.name}
                  </button>
                ))}
              </div>
              <div className="mt-3 text-sm text-purple-800">
                <span className="font-bold">Note:</span> En mode DEBUG, vous pouvez tester toutes les questions sans vous déplacer physiquement.
              </div>
            </div>
          )}
          
          {nearbyLocation && (
            <div className={`${solvedLocations.includes(nearbyLocation.name) ? 'bg-green-100 border-green-400 text-green-700' : 'bg-yellow-100 border-yellow-400 text-yellow-700'} border px-4 py-3 rounded mb-4`}>
              <h3 className="font-bold">{nearbyLocation.name}</h3>
              
              {/* Affichage du mot croisé ou de la question standard selon la location */}
              {nearbyLocation.usesCrossword ? (
                solvedLocations.includes(nearbyLocation.name) ? (
                  <div className="bg-white p-3 rounded">
                    <p>Énigme résolue ! Vous avez obtenu la lettre : <span className="font-bold text-xl">{nearbyLocation.letter}</span></p>
                  </div>
                ) : (
                  <CrosswordPuzzle 
                    onSolve={handleCrosswordSolve} 
                    onWrongAnswer={loseLife}
                    debugMode={debugMode} 
                  />
                )
              ) : (
                <div>
                  <p className="mb-3">{nearbyLocation.question}</p>
                  
                  {nearbyLocation.image && (
                    <img 
                      src={nearbyLocation.image} 
                      alt={nearbyLocation.name} 
                      className="w-full h-40 object-cover rounded mb-3"
                    />
                  )}
                  
                  {solvedLocations.includes(nearbyLocation.name) ? (
                    <div className="bg-white p-3 rounded">
                      <p>Énigme résolue ! Vous avez obtenu la lettre : <span className="font-bold text-xl">{nearbyLocation.letter}</span></p>
                    </div>
                  ) : lives <= 0 ? (
                    <div className="bg-red-100 p-3 rounded text-center">
                      <p className="text-red-700 font-bold">Vous n'avez plus de vies !</p>
                      <p className="text-red-600 text-sm mb-2">Envoyez un compliment à Loïs pour regagner une vie</p>
                      <button 
                        onClick={() => setShowComplimentModal(true)}
                        className="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded"
                      >
                        Regagner une vie
                      </button>
                    </div>
                  ) : (
                    <div>
                      {nearbyLocation.options && (
                        <div className="mb-3">
                          {nearbyLocation.options.map((option, idx) => (
                            <div 
                              key={idx} 
                              className={`p-2 mb-2 bg-white border rounded cursor-pointer hover:bg-yellow-50 ${userAnswer === option ? 'bg-yellow-100 border-yellow-500' : ''}`}
                              onClick={() => {
                                // Si l'option sélectionnée est exactement la réponse attendue
                                if (option === nearbyLocation.answer) {
                                  setUserAnswer(option);
                                } 
                                // Pour les cas où la réponse attendue est juste une partie de l'option
                                else if (option.includes(nearbyLocation.answer)) {
                                  setUserAnswer(nearbyLocation.answer);
                                }
                                // Sinon, sauvegarder l'option complète
                                else {
                                  setUserAnswer(option);
                                }
                              }}
                            >
                              {option}
                            </div>
                          ))}
                        </div>
                      )}
                      <input
                        type="text"
                        value={userAnswer}
                        onChange={(e) => setUserAnswer(e.target.value)}
                        placeholder="Votre réponse"
                        className="w-full p-2 border rounded mb-2"
                      />
                      <button 
                        onClick={checkAnswer}
                        className="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-medium py-2 px-4 rounded"
                      >
                        Valider
                      </button>
                    </div>
                  )}
                </div>
              )}
            </div>
          )}
          
          {/* Section pour deviner le mot secret */}
          <div className="mt-6 p-4 bg-purple-100 rounded-lg border border-purple-300">
            <h3 className="font-bold text-purple-800 mb-2">Lettres découvertes :</h3>
            <div className="flex flex-wrap gap-2 mb-4">
              {getFoundLetters().split('').map((letter, index) => (
                <div key={index} className="w-10 h-10 flex items-center justify-center bg-purple-500 text-white font-bold rounded">
                  {letter}
                </div>
              ))}
              {getFoundLetters().length === 0 && (
                <p className="text-purple-700">Aucune lettre découverte pour le moment...</p>
              )}
            </div>
            
            <h3 className="font-bold text-purple-800 mb-2">Mot secret :</h3>
            <div className="flex">
              <input
                type="text"
                value={secretWord}
                onChange={(e) => setSecretWord(e.target.value)}
                placeholder="Entrez le mot secret"
                className="flex-grow p-2 border rounded-l"
                disabled={lives <= 0}
              />
              <button 
                onClick={checkSecretWord}
                className={`bg-purple-500 hover:bg-purple-600 text-white font-medium py-2 px-4 rounded-r ${lives <= 0 ? 'opacity-50 cursor-not-allowed' : ''}`}
                disabled={lives <= 0}
              >
                Vérifier
              </button>
            </div>
            
            {lives <= 0 && (
              <div className="mt-2 text-center text-red-600 text-sm">
                <p>Vous n'avez plus de vies. Regagnez des vies pour continuer.</p>
              </div>
            )}
          </div>
          
          <div className="mt-6">
            <h3 className="font-medium text-gray-700 mb-2">Lieux d'intérêt à découvrir :</h3>
            <ul className="list-disc pl-5 text-gray-600">
              {locations.map((loc, index) => (
                <li key={index} className={solvedLocations.includes(loc.name) ? "line-through text-green-600" : ""}>
                  {loc.name}
                </li>
              ))}
            </ul>
          </div>
          
          {/* Modal pour gagner une vie */}
          {showComplimentModal && (
            <ComplimentModal 
              onClose={() => setShowComplimentModal(false)}
              onLifeGained={gainLife}
            />
          )}
          
          {/* Modal de perte de vie */}
          {showLifeLostModal && (
            <div className="life-modal">
              <div className="modal-content bg-red-100">
                <div className="text-4xl mb-2">💔</div>
                <h3 className="text-xl font-bold mb-2 text-red-700">Vous avez perdu une vie!</h3>
                <p className="mb-3">Il vous reste {lives} vie(s).</p>
                {lives === 0 && (
                  <button 
                    onClick={() => {
                      setShowLifeLostModal(false);
                      setShowComplimentModal(true);
                    }}
                    className="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded"
                  >
                    Regagner une vie
                  </button>
                )}
              </div>
            </div>
          )}
        </div>
      );
    };

    ReactDOM.render(<TreasureHunt />, document.getElementById('root'));
  </script>
</body>
</html>