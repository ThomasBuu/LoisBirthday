<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ijbol qu√™te</title>
  <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    .text-xxs {
      font-size: 0.65rem;
    }
    .overflow-x-auto::-webkit-scrollbar {
      height: 4px;
    }
    .overflow-x-auto::-webkit-scrollbar-thumb {
      background-color: rgba(156, 163, 175, 0.5);
      border-radius: 2px;
    }
    .overflow-x-auto::-webkit-scrollbar-track {
      background-color: rgba(229, 231, 235, 0.5);
    }
    @media (max-width: 640px) {
      .grid-item-small {
        width: 22px;
        height: 22px;
      }
    }
    .max-w-crossword {
      max-width: 300px;
      margin: 0 auto;
    }
    /* Animation pour c≈ìur qui bat */
    @keyframes heartbeat {
      0% { transform: scale(1); }
      25% { transform: scale(1.1); }
      50% { transform: scale(1); }
      75% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    .heartbeat {
      animation: heartbeat 1s infinite;
      display: inline-block;
    }
    .hearts-container {
      display: flex;
      gap: 0.25rem;
    }
    /* Animation pour c≈ìur perdu */
    @keyframes heartLost {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0.5; }
      100% { transform: scale(0); opacity: 0; }
    }
    .heart-lost {
      animation: heartLost 0.5s forwards;
    }
    /* Animation pour c≈ìur gagn√© */
    @keyframes heartGained {
      0% { transform: scale(0); opacity: 0; }
      50% { transform: scale(1.5); opacity: 0.5; }
      100% { transform: scale(1); opacity: 1; }
    }
    .heart-gained {
      animation: heartGained 0.5s forwards;
    }
    /* Modal de perte de vie */
    .life-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .modal-content {
      background-color: white;
      padding: 2rem;
      border-radius: 1rem;
      text-align: center;
      max-width: 90%;
      width: 400px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
    }
    /* Style pour le bouton MAP */
    .map-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background-color: #3B82F6;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .map-button:hover {
      background-color: #2563EB;
      transform: scale(1.05);
    }
    /* Modal de carte */
    .map-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .map-modal-content {
      position: relative;
      max-width: 90%;
      max-height: 90%;
      overflow: auto;
      border-radius: 0.5rem;
      background-color: white;
    }
    .map-modal-content img {
      max-width: 100%;
      display: block;
    }
    .close-button {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(255, 255, 255, 0.8);
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
  </style>
</head>
<body class="bg-gray-100">
  <div id="root"></div>
  
  <script type="text/babel">
    // Composant de Modal pour la carte
    const MapModal = ({ onClose }) => {
      return (
        <div className="map-modal" onClick={onClose}>
          <div className="map-modal-content" onClick={(e) => e.stopPropagation()}>
            <img src="images/map.png" alt="Carte du tr√©sor" />
            <div className="close-button" onClick={onClose}>√ó</div>
          </div>
        </div>
      );
    };
    
    // Composant de mot crois√©
    const CrosswordPuzzle = ({ onSolve, onWrongAnswer, debugMode }) => {
      const [userAnswers, setUserAnswers] = React.useState([]);
      const [isSolved, setIsSolved] = React.useState(false);
      const [gridData, setGridData] = React.useState(null);
      const [focusedCell, setFocusedCell] = React.useState(null);
      const [error, setError] = React.useState(null);
      const [attemptsLeft, setAttemptsLeft] = React.useState(3); // On donne 3 essais pour le mot crois√©
      
      // Initialisation de la grille
      React.useEffect(() => {
        try {
          // Donn√©es de la grille de mots crois√©s
          const data = {
            "grid": [
              [
                { "type": "black" }, { "type": "black" }, { "type": "white", "number": 1 }, { "type": "black" }, { "type": "black" }, 
                { "type": "white", "number": 2 }, { "type": "black" }, { "type": "white", "number": 3 }, { "type": "white" }, 
                { "type": "white", "number": 4 }, { "type": "black" }, { "type": "black" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "white" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "white" }, 
                { "type": "black" }, { "type": "black" }
              ],
              [
                { "type": "white", "number": 5 }, { "type": "white" }, { "type": "white" }, { "type": "white" }, { "type": "white" }, 
                { "type": "red" }, { "type": "white" }, { "type": "white" }, { "type": "black" }, { "type": "white" }, 
                { "type": "black" }, { "type": "black" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "white" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "white" }, 
                { "type": "black" }, { "type": "black" }
              ],
              [
                { "type": "white", "number": 6 }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "white" }, { "type": "black" }, { "type": "white", "number": 7 }, { "type": "black" }, { "type": "white" }, 
                { "type": "black" }, { "type": "black" }
              ],
              [
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "white", "number": 8 }, 
                { "type": "white" }, { "type": "white" }, { "type": "white" }, { "type": "white" }, { "type": "white" }, 
                { "type": "white"}, { "type": "white" , "number": 9 }
              ],
              [
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "white", "number": 10 }, { "type": "white" }, { "type": "white" }, { "type": "white" }, { "type": "white" }, 
                { "type": "white" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white", "number": 11 }, { "type": "white" }, { "type": "white" }, { "type": "white" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "black" }, { "type": "white" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ],
              [
                { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, { "type": "black" }, 
                { "type": "black" }, { "type": "white" }
              ]
            ],
            "clues": {
              "across": [
                { "number": 3, "clue": "Album pr√©f√©r√© de Lo√Øs" },
                { "number": 5, "clue": "Ville et couleur" },
                { "number": 8, "clue": "Vrai pr√©nom de Dan" },
                { "number": 10, "clue": "Animal pr√©f√©r√© de Lo√Øs" },
                { "number": 11, "clue": "Dans quelle ville est N√â Lo√Øs" }
              ],
              "down": [
                { "number": 1, "clue": "Film d'horreur/slasher pref de Lo√Øs" },
                { "number": 2, "clue": "Alcool pr√©f√©r√© de Lo√Øs" },
                { "number": 4, "clue": "i m not a drag queen I m the queen of drag" },
                { "number": 6, "clue": "Taylor" },
                { "number": 7, "clue": "macaque tib√©tain manchot" },
                { "number": 9, "clue": "Boutique ou Lo√Øs travaille" }
              ]
            }
          };
          
          // Initialiser les tableaux pour les r√©ponses utilisateur
          const emptyAnswers = data.grid.map(row => 
            row.map(cell => cell.type === "white" ? "" : null)
          );
          
          setGridData(data);
          setUserAnswers(emptyAnswers);
        } catch (err) {
          setError("Erreur lors du chargement des donn√©es: " + err.message);
        }
      }, []);
      
      // Solutions attendues avec les tailles correctes
      const expectedSolutions = {
        "across": {
          3: "nfr",
          5: "bordeaux",
          8: "danielle",
          10: "tortue",
          11: "nice"
        },
        "down": {
          1: "terrifier",
          2: "champagne",
          4: "rupaul",
          6: "swift",
          7: "xingxing",
          9: "ethereal"
        }
      };
      
      // Fonction pour remplir automatiquement une r√©ponse (triche)
      const fillAnswer = (direction, number) => {
        // Obtenir la solution attendue
        const solution = expectedSolutions[direction][number];
        if (!solution) return;
        
        // Trouver la position de d√©part
        let startPos = null;
        for (let i = 0; i < gridData.grid.length; i++) {
          for (let j = 0; j < gridData.grid[i].length; j++) {
            if (gridData.grid[i][j].type === "white" && 
                gridData.grid[i][j].number === number) {
              startPos = { row: i, col: j };
              break;
            }
          }
          if (startPos) break;
        }
        
        if (!startPos) return;
        
        // Cr√©er une copie des r√©ponses actuelles
        const newAnswers = [...userAnswers];
        
        // Remplir les cases selon la direction
        if (direction === "across") {
          // Horizontal (de gauche √† droite)
          for (let i = 0; i < solution.length; i++) {
            const col = startPos.col + i;
            if (col < gridData.grid[startPos.row].length && 
                gridData.grid[startPos.row][col].type === "white") {
              newAnswers[startPos.row][col] = solution[i];
            }
          }
        } else if (direction === "down") {
          // Vertical (de haut en bas)
          for (let i = 0; i < solution.length; i++) {
            const row = startPos.row + i;
            if (row < gridData.grid.length && 
                gridData.grid[row] && 
                gridData.grid[row][startPos.col] && 
                gridData.grid[row][startPos.col].type === "white") {
              newAnswers[row][startPos.col] = solution[i];
            }
          }
        }
        
        setUserAnswers(newAnswers);
      };
      
      // Remplir toute la grille en un clic (bouton "Triche compl√®te")
      const fillAllAnswers = () => {
        // Remplir d'abord les mots horizontaux
        Object.keys(expectedSolutions.across).forEach(number => {
          fillAnswer("across", parseInt(number));
        });
        
        // Puis les mots verticaux
        Object.keys(expectedSolutions.down).forEach(number => {
          fillAnswer("down", parseInt(number));
        });
        
        // V√©rifier automatiquement apr√®s remplissage complet
        setTimeout(() => checkSolution(), 300);
      };
      

      // Modification du composant CrosswordPuzzle pour ajouter la fonctionnalit√© de la case rouge

      // Mettre √† jour la fonction handleInputChange pour g√©rer le cas sp√©cial
      const handleInputChange = (rowIndex, colIndex, value) => {
        // Accepter uniquement une lettre
        if (value.length > 1) {
          value = value.charAt(value.length - 1);
        }
        
        // Convertir en majuscule
        value = value.toUpperCase();
        
        // Mettre √† jour les r√©ponses de l'utilisateur
        const newAnswers = [...userAnswers];
        newAnswers[rowIndex][colIndex] = value;
        setUserAnswers(newAnswers);
        
        // Si une lettre a √©t√© saisie, d√©placer le focus vers la cellule suivante
        // Seulement si on n'est pas en mode derni√®re chance (o√π on ne remplit qu'une case)
        if (value !== "" && attemptsLeft > 0) {
          moveToNextCell(rowIndex, colIndex);
        }
      };

      
      // Fonction pour g√©rer la touche Backspace et les fl√®ches
      const handleKeyDown = (e, rowIndex, colIndex) => {
        if (e.key === "Backspace" && userAnswers[rowIndex][colIndex] === "") {
          e.preventDefault();
          moveToPrevCell(rowIndex, colIndex);
        } else if (e.key === "ArrowRight") {
          e.preventDefault();
          moveHorizontal(rowIndex, colIndex, 1);
        } else if (e.key === "ArrowLeft") {
          e.preventDefault();
          moveHorizontal(rowIndex, colIndex, -1);
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          moveVertical(rowIndex, colIndex, -1);
        } else if (e.key === "ArrowDown") {
          e.preventDefault();
          moveVertical(rowIndex, colIndex, 1);
        }
      };
      
      // D√©placer vers la cellule suivante (horizontalement)
      const moveToNextCell = (rowIndex, colIndex) => {
        // Essayer de trouver la prochaine cellule blanche horizontalement
        let nextCol = colIndex + 1;
        while (nextCol < gridData.grid[rowIndex].length) {
          if (gridData.grid[rowIndex][nextCol].type === "white") {
            focusCell(rowIndex, nextCol);
            return;
          }
          nextCol++;
        }
        
        // Si pas trouv√©, essayer la ligne suivante
        let nextRow = rowIndex + 1;
        while (nextRow < gridData.grid.length) {
          for (let col = 0; col < gridData.grid[nextRow].length; col++) {
            if (gridData.grid[nextRow][col].type === "white") {
              focusCell(nextRow, col);
              return;
            }
          }
          nextRow++;
        }
      };
      
      // D√©placer vers la cellule pr√©c√©dente
      const moveToPrevCell = (rowIndex, colIndex) => {
        let prevCol = colIndex - 1;
        while (prevCol >= 0) {
          if (gridData.grid[rowIndex][prevCol].type === "white") {
            focusCell(rowIndex, prevCol);
            return;
          }
          prevCol--;
        }
        
        // Si pas trouv√©, essayer la ligne pr√©c√©dente
        let prevRow = rowIndex - 1;
        while (prevRow >= 0) {
          for (let col = gridData.grid[prevRow].length - 1; col >= 0; col--) {
            if (gridData.grid[prevRow][col].type === "white") {
              focusCell(prevRow, col);
              return;
            }
          }
          prevRow--;
        }
      };
      
      // D√©placer horizontalement
      const moveHorizontal = (rowIndex, colIndex, direction) => {
        let nextCol = colIndex + direction;
        while (nextCol >= 0 && nextCol < gridData.grid[rowIndex].length) {
          if (gridData.grid[rowIndex][nextCol].type === "white") {
            focusCell(rowIndex, nextCol);
            return;
          }
          nextCol += direction;
        }
      };
      
      // D√©placer verticalement
      const moveVertical = (rowIndex, colIndex, direction) => {
        let nextRow = rowIndex + direction;
        while (nextRow >= 0 && nextRow < gridData.grid.length) {
          if (gridData.grid[nextRow][colIndex].type === "white") {
            focusCell(nextRow, colIndex);
            return;
          }
          nextRow += direction;
        }
      };
      
      // Mettre le focus sur une cellule
      const focusCell = (rowIndex, colIndex) => {
        setFocusedCell({ row: rowIndex, col: colIndex });
        
        setTimeout(() => {
          const input = document.getElementById(`cell-${rowIndex}-${colIndex}`);
          if (input) {
            input.focus();
          }
        }, 0);
      };
      
      // V√©rifier si le mot crois√© est correctement rempli
      // Modifier la fonction checkSolution pour g√©rer le cas sp√©cial de la case rouge
      const checkSolution = () => {
        // Si plus d'essais, on v√©rifie uniquement la case rouge
        if (attemptsLeft === 0) {
          // Trouver la position de la case rouge
          let redCellPosition = null;
          for (let i = 0; i < gridData.grid.length; i++) {
            for (let j = 0; j < gridData.grid[i].length; j++) {
              if (gridData.grid[i][j].type === "red") {
                redCellPosition = { row: i, col: j };
                break;
              }
            }
            if (redCellPosition) break;
          }
          
          // V√©rifier si la lettre dans la case rouge est correcte (devrait √™tre "A")
          if (redCellPosition && userAnswers[redCellPosition.row][redCellPosition.col] === "A") {
            setIsSolved(true);
            if (onSolve) {
              onSolve("A");
            }
          } else {
            // Perdre une vie UNIQUEMENT ici, si la solution de la case rouge n'est pas correcte
            if (onWrongAnswer) {
              onWrongAnswer();
            }
            alert("R√©ponse incorrecte pour la case rouge. Vous perdez une vie !");
          }
          return;
        }
        
        // Logique originale pour les essais normaux
        // Pour faciliter les tests, consid√©rer comme correct si au moins 70% des lettres sont saisies
        let filledCells = 0;
        let totalCells = 0;
        
        // Compter les cellules remplies
        for (let i = 0; i < gridData.grid.length; i++) {
          for (let j = 0; j < gridData.grid[i].length; j++) {
            if (gridData.grid[i][j].type === "white" || gridData.grid[i][j].type === "red") {
              totalCells++;
              if (userAnswers[i][j] && userAnswers[i][j] !== "") {
                filledCells++;
              }
            }
          }
        }
        
        // Calculer le pourcentage de remplissage
        const fillPercentage = (filledCells / totalCells) * 100;
        
        // Si au moins 70% des cellules sont remplies, consid√©rer comme r√©solu
        if (fillPercentage >= 70) {
          setIsSolved(true);
          if (onSolve) {
            onSolve("A"); // Retourne la lettre "A" correspondant √† l'√©nigme de la grotte
          }
        } else {
          // R√©duire le nombre d'essais sans perdre de vie
          if (attemptsLeft > 0) {
            setAttemptsLeft(attemptsLeft - 1);
            // Ne PAS appeler onWrongAnswer ici pour √©viter de perdre une vie pendant les 3 essais
            alert(`La grille est remplie √† ${Math.round(fillPercentage)}%, il faut au moins 70% pour valider. Il vous reste ${attemptsLeft - 1} essai(s).`);
            
            // Si c'√©tait le dernier essai, ajouter un message suppl√©mentaire
            if (attemptsLeft - 1 === 0) {
              setTimeout(() => {
                alert("Vous pouvez maintenant essayer de deviner uniquement la lettre dans la case rouge. Attention: une erreur vous fera perdre une vie!");
              }, 500);
            }
          } else {
            alert("Vous n'avez plus d'essais disponibles. Essayez de trouver la lettre dans la case rouge!");
          }
        }
      };
      
      // Si les donn√©es ne sont pas encore charg√©es
      if (!gridData) {
        return <div>Chargement du mot crois√©...</div>;
      }
      
      // Si une erreur est survenue
      if (error) {
        return <div className="text-red-600">{error}</div>;
      }
      
      return (
        <div className="p-4 bg-white rounded-xl shadow">
          <h3 className="text-xl font-bold mb-4">Mot Crois√© - La Grotte</h3>
          
          {isSolved ? (
            <div className="bg-green-100 p-4 rounded text-green-800 mb-4">
              <p className="font-bold">Bravo ! Vous avez r√©solu le mot crois√©.</p>
              <p>Vous avez obtenu la lettre : <span className="text-2xl font-bold">A</span></p>
            </div>
          ) : (
            <div className="mb-4">
              <p className="text-gray-700 mb-2">
                Remplissez le mot crois√© pour d√©bloquer l'indice de la grotte.
                Si vous ne trouvez pas tout, la lettre qui croise le 5 et le 2 est la solution  
              </p>
              <div className="flex justify-between items-center mb-2">
                <span className="text-sm text-gray-600">Essais restants: {attemptsLeft}</span>
                {debugMode && (
                  <button 
                    onClick={fillAllAnswers}
                    className="mt-2 bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-2 rounded text-sm"
                  >
                    Triche compl√®te
                  </button>
                )}
              </div>
            </div>
          )}
          
          <div className="flex flex-col gap-4">
            {/* Grille de mot crois√© */}
          <div className="w-full overflow-x-auto pb-2">
            <div className="max-w-crossword">
              <div 
                className="grid gap-px bg-gray-300 inline-block mx-auto"
                style={{ 
                  gridTemplateRows: `repeat(${gridData.grid.length}, 25px)`,
                  gridTemplateColumns: `repeat(${gridData.grid[0].length}, 25px)`
                }}
              >
                {gridData.grid.map((row, rowIndex) => (
                  row.map((cell, colIndex) => (
                    <div
                      key={`${rowIndex}-${colIndex}`}
                      className={`relative flex items-center justify-center grid-item-small
                        ${cell.type === "black" ? "bg-black" : 
                          cell.type === "red" && attemptsLeft === 0 ? "bg-red-300" : 
                          cell.type === "red" ? "bg-white" : "bg-white"}
                        ${focusedCell && focusedCell.row === rowIndex && focusedCell.col === colIndex 
                          ? "ring-1 ring-blue-500" : ""}
                      `}
                      onClick={() => (cell.type === "white" || cell.type === "red") && focusCell(rowIndex, colIndex)}
                    >
                      {(cell.type === "white" || cell.type === "red") && cell.number && (
                        <span className="absolute top-0 left-0.5 text-xxs md:text-xs font-semibold text-gray-500">
                          {cell.number}
                        </span>
                      )}
                      
                      {(cell.type === "white" || cell.type === "red") && (
                        <input
                          id={`cell-${rowIndex}-${colIndex}`}
                          type="text"
                          maxLength="1"
                          className="w-full h-full text-center font-bold uppercase bg-transparent outline-none text-xs md:text-base"
                          value={userAnswers[rowIndex] && userAnswers[rowIndex][colIndex] ? userAnswers[rowIndex][colIndex] : ""}
                          onChange={(e) => handleInputChange(rowIndex, colIndex, e.target.value)}
                          onKeyDown={(e) => handleKeyDown(e, rowIndex, colIndex)}
                          disabled={isSolved || (attemptsLeft === 0 && cell.type !== "red")}
                        />
                      )}
                    </div>
                  ))
                ))}
              </div>
              
              {!isSolved && (
                <button 
                  onClick={checkSolution}
                  className={`mt-4 w-full ${attemptsLeft === 0 ? 'bg-red-500 hover:bg-red-600' : 'bg-blue-500 hover:bg-blue-600'} text-white font-bold py-2 px-4 rounded`}
                >
                  {attemptsLeft === 0 ? "V√©rifier la case rouge" : "V√©rifier la solution"}
                </button>
              )}
              
              {!isSolved && attemptsLeft === 0 && (
                <div className="mt-4 bg-red-100 p-3 rounded border border-red-300 text-red-700 text-center">
                  <p>Plus d'essais disponibles! Trouvez la lettre dans la case rouge (maintenant color√©e). Attention: une erreur vous fera perdre une vie!</p>
                </div>
              )}
            </div>
          </div>
            
            {/* Indices */}
            <div className="w-full">
              <div className="bg-gray-100 p-4 rounded">
                <div className="mb-4">
                  <h4 className="font-bold text-lg mb-2">Horizontalement</h4>
                  <ul className="space-y-2">
                    {gridData.clues.across.map((clue) => (
                      <li key={`across-${clue.number}`} className="flex items-center">
                        <span className="font-semibold mr-1">{clue.number}.</span> {clue.clue}
                        {debugMode && !isSolved && (
                          <button 
                            onClick={() => fillAnswer("across", clue.number)}
                            className="ml-2 bg-red-500 hover:bg-red-600 text-white font-bold py-0.5 px-1 rounded text-xs"
                          >
                            Triche
                          </button>
                        )}
                      </li>
                    ))}
                  </ul>
                </div>
                
                <div>
                  <h4 className="font-bold text-lg mb-2">Verticalement</h4>
                  <ul className="space-y-2">
                    {gridData.clues.down.map((clue) => (
                      <li key={`down-${clue.number}`} className="flex items-center">
                        <span className="font-semibold mr-1">{clue.number}.</span> {clue.clue}
                        {debugMode && !isSolved && (
                          <button 
                            onClick={() => fillAnswer("down", clue.number)}
                            className="ml-2 bg-red-500 hover:bg-red-600 text-white font-bold py-0.5 px-1 rounded text-xs"
                          >
                            Triche
                          </button>
                        )}
                      </li>
                    ))}
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    // Composant modal pour envoyer un compliment
    const ComplimentModal = ({ onClose, onLifeGained }) => {
      const compliments = [
        "Lo√Øs, tu es vraiment l'esprit le plus brillant que je connaisse et un ami hors pair.",
        "Lo√Øs, ta bienveillance illumine chaque instant et rend la vie plus douce.",
        "Lo√Øs, j'admire ta sagesse et ta loyaut√© : tu es un tr√©sor d'amiti√©.",
        "Lo√Øs, ta pr√©sence transforme les pires journ√©es en moments magiques.",
        "Lo√Øs, tu as un c≈ìur en or et ta g√©n√©rosit√© n'a d'√©gale que ta joie de vivre.",
        "Lo√Øs, tu es l'exemple parfait d'un ami fid√®le sur qui on peut toujours compter.",
        "Lo√Øs, ta cr√©ativit√© et ton empathie font de toi un alli√© incomparable.",
        "Lo√Øs, ton intelligence et ton humour font de chaque conversation un pur bonheur.",
        "Lo√Øs, ta force tranquille et ton soutien sont un cadeau pour ceux qui t'entourent.",
        "Lo√Øs, tu incarnes l'amiti√© id√©ale : sinc√®re, g√©n√©reuse et inspirante."
      ];
      
      const sendCompliment = () => {
        // Choix al√©atoire
        const randomIndex = Math.floor(Math.random() * compliments.length);
        const message = compliments[randomIndex];
        
        // Envoyer le SMS
        window.location.href = `sms:+33634481088?body=${encodeURIComponent(message)}`;
        
        // Notifier que la vie est gagn√©e
        setTimeout(() => {
          onLifeGained();
          onClose();
        }, 500);
      };
      
      return (
        <div className="life-modal">
          <div className="modal-content">
            <h3 className="text-xl font-bold mb-4">Regagner une vie ‚ù§Ô∏è</h3>
            <p className="mb-4">Envoie un compliment √† Lo√Øs pour regagner une vie et continuer l'aventure !</p>
            
            <div className="flex space-x-2 justify-center mb-4">
              <button 
                onClick={sendCompliment}
                className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition"
              >
                Envoyer un compliment
              </button>
              <button 
                onClick={onClose}
                className="px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 transition"
              >
                Annuler
              </button>
            </div>
            
            <p className="text-xs text-gray-500">
              Un SMS sera automatiquement pr√©par√© avec un compliment al√©atoire. Tu n'auras plus qu'√† l'envoyer !
            </p>
          </div>
        </div>
      );
    };

    // Application principale de chasse au tr√©sor
    const TreasureHunt = () => {
      const [currentPosition, setCurrentPosition] = React.useState(null);
      const [nearbyLocation, setNearbyLocation] = React.useState(null);
      const [error, setError] = React.useState(null);
      const [distance, setDistance] = React.useState(null);
      const [permissionStatus, setPermissionStatus] = React.useState('pending');
      const [userAnswer, setUserAnswer] = React.useState('');
      const [solvedLocations, setSolvedLocations] = React.useState([]);
      const [secretWord, setSecretWord] = React.useState('');
      const [debugMode, setDebugMode] = React.useState(false);
      const [selectedDebugLocation, setSelectedDebugLocation] = React.useState(null);
      const [lives, setLives] = React.useState(3); // Vies par d√©faut
      const [showComplimentModal, setShowComplimentModal] = React.useState(false);
      const [showLifeLostModal, setShowLifeLostModal] = React.useState(false);
      const [showMapModal, setShowMapModal] = React.useState(false); // √âtat pour la modale de carte
      const [startTime, setStartTime] = React.useState(null);  // Heure de d√©but
      const [elapsedTime, setElapsedTime] = React.useState(0); // Temps √©coul√©
      const [watchId, setWatchId] = React.useState(null);      // ID du watcher de g√©olocalisation

      // Charger les donn√©es depuis les cookies au d√©marrage
      React.useEffect(() => {
        const savedLocations = localStorage.getItem('solvedLocations');
        if (savedLocations) {
          setSolvedLocations(JSON.parse(savedLocations));
        }
        
        // Charger le nombre de vies depuis les cookies
        const savedLives = getCookie('lives');
        if (savedLives) {
          setLives(parseInt(savedLives));
        } else {
          // Si pas de cookie, initialiser √† 3 vies
          setCookie('lives', 3, 7); // Expire dans 7 jours
        }
        
        // Charger le temps de d√©part depuis les cookies
        const savedStartTime = getCookie('startTime');
        if (savedStartTime) {
          setStartTime(parseInt(savedStartTime));
          setPermissionStatus('granted');
          requestLocation(); // Redemander la g√©olocalisation si on a d√©j√† commenc√©
        }
      }, []);

      // Sauvegarder les donn√©es dans localStorage √† chaque mise √† jour
      React.useEffect(() => {
        if (solvedLocations.length > 0) {
          localStorage.setItem('solvedLocations', JSON.stringify(solvedLocations));
        }
      }, [solvedLocations]);
      
      // Sauvegarder les vies dans les cookies √† chaque mise √† jour
      React.useEffect(() => {
        setCookie('lives', lives, 7); // Expire dans 7 jours
      }, [lives]);
      
      // Effet pour mettre √† jour le chronom√®tre chaque seconde
      React.useEffect(() => {
        if (startTime) {
          const intervalId = setInterval(() => {
            const now = Date.now();
            const elapsed = Math.floor((now - startTime) / 1000); // Temps √©coul√© en secondes
            setElapsedTime(elapsed);
          }, 1000);
          
          return () => clearInterval(intervalId);
        }
      }, [startTime]);
      
      // Fonctions pour g√©rer les cookies
      const setCookie = (name, value, days) => {
        let expires = "";
        if (days) {
          const date = new Date();
          date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
          expires = "; expires=" + date.toUTCString();
        }
        document.cookie = name + "=" + value + expires + "; path=/";
      };
      
      const getCookie = (name) => {
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++) {
          let c = ca[i];
          while (c.charAt(0) === ' ') c = c.substring(1, c.length);
          if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
      };
      
      // Fonction pour d√©marrer le chronom√®tre
      const startTimer = () => {
        // V√©rifier si un chronom√®tre existe d√©j√† dans les cookies
        const savedStartTime = getCookie('startTime');
        
        if (savedStartTime) {
          setStartTime(parseInt(savedStartTime));
        } else {
          const now = Date.now();
          setStartTime(now);
          setCookie('startTime', now.toString(), 7); // 7 jours d'expiration
        }
      };
      
      // Formater le temps en heures:minutes:secondes
      const formatTime = (timeInSeconds) => {
        const hours = Math.floor(timeInSeconds / 3600);
        const minutes = Math.floor((timeInSeconds % 3600) / 60);
        const seconds = timeInSeconds % 60;
        
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      };
      
      // Fonction pour perdre une vie
      const loseLife = () => {
        if (lives > 0) {
          setLives(lives - 1);
          setShowLifeLostModal(true);
          
          // Fermer la modal apr√®s 2 secondes
          setTimeout(() => {
            setShowLifeLostModal(false);
          }, 2000);
        }
      };
      
      // Fonction pour gagner une vie
      const gainLife = () => {
        setLives(lives + 1);
      };
      
      // Liste des lieux avec les lettres modifi√©es pour former "PARIS"
      const locations = [
        { 
          name: "Barques", 
          lat: 48.83300, 
          lng: 2.40986, 
          question: "Combien Lo√Øs va-t-il payer individuellement si il va faire de la barque au lac de Dausmenil avec Luna pendant 3heures ?", 
          options: [
            "37,00‚Ç¨",
            "39,50‚Ç¨",
            "47,40‚Ç¨",
            "79,00‚Ç¨"
          ],
          answer: "39,50", 
          letter: "S", // Modifi√©: E ‚Üí S
          image: "images/barque.png" // Utilisation de l'image locale
        },
        { 
          name: "√éle des paons", 
          lat: 48.83105, 
          lng: 2.41189, 
          question: "Quel oiseau ne trouve-t-on pas sur le lac de daumesnil ?", 
          options: [
            "Oie de Guin√©e",
            "Canard colvert",
            "Foulque",
            "Cygne"
          ],
          answer: "Oie de Guin√©e", 
          letter: "R", // Modifi√©: N ‚Üí R
          image: "images/ile.png" // Utilisation de l'image locale
        },
        { 
          name: "Grotte", 
          lat: 48.83003, 
          lng: 2.41575,
          usesCrossword: true, // Param√®tre pour indiquer qu'on utilise un mot crois√©
          question: "Compl√©tez le mot crois√© pour obtenir la lettre", 
          answer: "", // Pas besoin de r√©ponse car g√©r√© par le composant de mot crois√©
          letter: "A", // Modifi√©: I ‚Üí A
          image: "images/grotte.png" // Utilisation de l'image locale
        },
        { 
          name: "P√®lerins des nuages et de l'eau", 
          lat: 48.82903, 
          lng: 2.41375, 
          question: "Dans un aquarium il y a 10 poissons rouges. 2 se sont noy√©s, 4 nagent entre les rochers et 3 sont morts. Combien de poissons rouges reste-t-il ?", 
          options: [
            "4",
            "5",
            "7",
            "10"
          ],
          answer: "10", 
          letter: "P", // Modifi√©: G ‚Üí P
          image: "images/statue.png" // Utilisation de l'image locale
        },
        { 
          name: "Pont sud", 
          lat: 48.82845, 
          lng: 2.41837, 
          question: "L'√Æle de Bercy est-elle un √Æle artificielle ? Si oui en quelle ann√©e a-t-elle √©t√© cr√©√©e ?", 
          options: [
            "Ce n'est pas une √Æle artificielle mais elle a √©t√© d√©couverte transform√©e en parc en 1690",
            "Ce n'est pas une √Æle artificielle mais elle a √©t√© d√©couverte transform√©e en parc en 1960",
            "Oui en 1960",
            "Oui en 1860"
          ],
          answer: "Oui en 1860", 
          letter: "I", // Modifi√©: M ‚Üí I
          image: "images/pont.png" // Utilisation de l'image locale
        }
      ];

      // Fonction pour calculer la distance entre deux points GPS (formule de Haversine)
      const calculateDistance = (lat1, lon1, lat2, lon2) => {
        const R = 6371000; // Rayon de la Terre en m√®tres
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = 
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      };

      // Fonction pour v√©rifier la proximit√© des lieux
      const checkProximity = (position) => {
        if (!position) return;
        
        const { latitude, longitude } = position.coords;
        
        // Ne pas v√©rifier la proximit√© si nous sommes en mode debug et qu'un lieu est s√©lectionn√©
        if (debugMode && selectedDebugLocation) {
          return;
        }
        
        // Trouver le lieu le plus proche
        let closestLocation = null;
        let minDistance = Infinity;
        
        locations.forEach(location => {
          const dist = calculateDistance(latitude, longitude, location.lat, location.lng);
          if (dist < minDistance) {
            minDistance = dist;
            closestLocation = { ...location, distance: dist };
          }
        });
        
        setDistance(minDistance);
        
        // Consid√©rer comme "proche" si moins de 100 m√®tres
        if (minDistance < 100) {
          setNearbyLocation(closestLocation);
        } else {
          setNearbyLocation(null);
        }
      };
      
            // Fonction pour supprimer tous les cookies et donn√©es locales
      const resetAllData = () => {
        // Supprimer tous les cookies
        document.cookie.split(";").forEach(function(c) {
          document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
        });
        
        // Supprimer les donn√©es de localStorage
        localStorage.removeItem('solvedLocations');
        
        // Alerter l'utilisateur
        alert("Toutes les donn√©es ont √©t√© r√©initialis√©es. La page va √™tre recharg√©e.");
        
        // Recharger la page
        window.location.reload();
      };
      
      // Demander la g√©olocalisation
      const requestLocation = () => {
        setPermissionStatus('requesting');
        
        if (!navigator.geolocation) {
          setError("La g√©olocalisation n'est pas support√©e par votre navigateur");
          setPermissionStatus('denied');
          return;
        }
        
        // D√©marrer le chronom√®tre
        startTimer();
        
        navigator.geolocation.getCurrentPosition(
          (position) => {
            setCurrentPosition(position);
            checkProximity(position);
            setPermissionStatus('granted');
            
            // Mettre √† jour la position r√©guli√®rement
            const id = navigator.geolocation.watchPosition(
              (newPosition) => {
                setCurrentPosition(newPosition);
                checkProximity(newPosition);
              },
              (err) => {
                setError(`Erreur: ${err.message}`);
                setPermissionStatus('error');
              }
            );
            
            setWatchId(id);
          },
          (err) => {
            if (err.code === 1) { // PERMISSION_DENIED
              setPermissionStatus('denied');
            }
            setError(`Erreur: ${err.message}`);
          },
          { enableHighAccuracy: true }
        );
      };

      // V√©rifier la r√©ponse de l'utilisateur
      const checkAnswer = () => {
        if (!nearbyLocation || lives <= 0) return;
        
        const isCorrect = userAnswer === nearbyLocation.answer;
        
        if (isCorrect && !solvedLocations.includes(nearbyLocation.name)) {
          const updatedSolvedLocations = [...solvedLocations, nearbyLocation.name];
          setSolvedLocations(updatedSolvedLocations);
          
          // V√©rifier si toutes les √©nigmes sont r√©solues
          if (updatedSolvedLocations.length === locations.length) {
            alert("F√©licitations ! Vous avez r√©solu toutes les √©nigmes ! Essayez maintenant de former le mot avec les lettres obtenues.");
          } else {
            alert(`Correct ! Vous avez obtenu la lettre "${nearbyLocation.letter}". Continuez √† chercher d'autres lieux !`);
          }
        } else if (isCorrect) {
          alert("Vous avez d√©j√† r√©solu cette √©nigme !");
        } else {
          // Perdre une vie si la r√©ponse est incorrecte
          loseLife();
          alert("R√©ponse incorrecte. Vous perdez une vie !");
        }
        
        setUserAnswer('');
      };
      
      // Fonction pour traiter la r√©solution du mot crois√©
      const handleCrosswordSolve = (letter) => {
        if (!solvedLocations.includes("Grotte")) {
          const updatedSolvedLocations = [...solvedLocations, "Grotte"];
          setSolvedLocations(updatedSolvedLocations);
          
          // V√©rifier si toutes les √©nigmes sont r√©solues
          if (updatedSolvedLocations.length === locations.length) {
            alert("F√©licitations ! Vous avez r√©solu toutes les √©nigmes ! Essayez maintenant de former le mot avec les lettres obtenues.");
          } else {
            alert(`Correct ! Vous avez obtenu la lettre "${letter}". Continuez √† chercher d'autres lieux !`);
          }
        }
      };
      
      // Mode DEBUG pour tester toutes les questions
      const activateDebugMode = () => {
        setDebugMode(true);
        alert("MODE DEBUG ACTIV√â ! Vous pouvez maintenant s√©lectionner un lieu √† tester et ajouter des vies.");
      };
      
      // S√©lectionner un lieu en mode DEBUG
      const selectDebugLocation = (location) => {
        setSelectedDebugLocation(location);
        setNearbyLocation(location);
        // D√©sactiver temporairement la surveillance GPS pour √©viter les interf√©rences
        if (watchId) {
          navigator.geolocation.clearWatch(watchId);
          setWatchId(null);
        }
      };

      // V√©rifier le mot secret
      // Modification de la fonction checkSecretWord existante
      const checkSecretWord = () => {
        // Le mot secret est "PARIS"
        if (secretWord.toLowerCase() === "paris") {
          window.location.href = "index2.html"; // Redirection vers la page de c√©l√©bration
        } else if (secretWord.toLowerCase() === "debug") {
          activateDebugMode();
          setSecretWord('');
        } else if (secretWord.toUpperCase() === "RESETALL") {
          // Nouveau cas pour r√©initialiser les donn√©es
          resetAllData();
        } else {
          // Perdre une vie pour mauvaise tentative
          loseLife();
          alert("Ce n'est pas le bon mot. Vous perdez une vie !");
          setSecretWord('');
        }
      };

      // Obtenir les lettres trouv√©es
      const getFoundLetters = () => {
        let letters = "";
        locations.forEach(location => {
          if (solvedLocations.includes(location.name)) {
            letters += location.letter;
          }
        });
        return letters;
      };

      // Rendu du composant principal
      return (
        <div className="p-4 max-w-md mx-auto bg-white rounded-xl shadow-md overflow-hidden relative">
          {/* Bouton MAP */}
          <div 
            className="map-button"
            onClick={() => setShowMapModal(true)}
          >
            MAP
          </div>

          {/* Modale de carte */}
          {showMapModal && (
            <MapModal onClose={() => setShowMapModal(false)} />
          )}
          
          {/* Barre de vie */}
          <div className="absolute top-2 right-2 flex items-center">
            <div className="hearts-container mr-2">
              {Array.from({ length: lives }).map((_, i) => (
                <span key={i} className="text-red-500 text-xl heartbeat">‚ù§Ô∏è</span>
              ))}
              {Array.from({ length: Math.max(0, 5 - lives) }).map((_, i) => (
                <span key={i} className="text-gray-300 text-xl">üñ§</span>
              ))}
            </div>
            <button 
              onClick={() => setShowComplimentModal(true)}
              className="bg-pink-500 hover:bg-pink-600 text-white text-xs rounded-full p-1"
              title="Gagner une vie"
            >
              +
            </button>
            {debugMode && (
              <button 
                onClick={() => setLives(Math.min(5, lives + 1))}
                className="ml-1 bg-purple-500 hover:bg-purple-600 text-white text-xs rounded-full p-1"
                title="DEBUG: Ajouter une vie"
              >
                +D
              </button>
            )}
          </div>
          
          <h2 className="text-xl font-bold text-gray-800 mb-4">ijbol qu√™te</h2>
          
          {/* Affichage du chronom√®tre */}
          <div className="flex items-center justify-between mb-4">
            {startTime && (
              <div className="text-gray-600 font-mono">
                <span className="font-medium">Temps √©coul√©:</span> {formatTime(elapsedTime)}
              </div>
            )}
          </div>
          
          {permissionStatus === 'pending' && (
            <button 
              onClick={requestLocation}
              className="w-full bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded mb-4">
              Commencer l'aventure
            </button>
          )}
          
          {permissionStatus === 'denied' && (
            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
              L'acc√®s √† votre position a √©t√© refus√©. Veuillez autoriser l'acc√®s √† votre position dans les param√®tres de votre navigateur.
            </div>
          )}
          
          {permissionStatus === 'requesting' && (
            <div className="text-gray-600 mb-4">
              Demande d'acc√®s √† votre position en cours...
            </div>
          )}
          
          {error && (
            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
              {error}
            </div>
          )}
          
          {currentPosition && (
            <div className="mb-4">
              <h3 className="font-medium text-gray-700">Votre position actuelle :</h3>
              <p className="text-gray-600">
                Latitude: {currentPosition.coords.latitude.toFixed(5)}¬∞<br />
                Longitude: {currentPosition.coords.longitude.toFixed(5)}¬∞<br />
                Pr√©cision: ¬±{currentPosition.coords.accuracy.toFixed(1)} m√®tres
              </p>
            </div>
          )}
          
          {distance !== null && !debugMode && (
            <div className="mb-4">
              <h3 className="font-medium text-gray-700">Distance au lieu le plus proche :</h3>
              <p className="text-gray-600">
                {distance < 1000 ? 
                  `${distance.toFixed(1)} m√®tres` : 
                  `${(distance/1000).toFixed(2)} kilom√®tres`}
              </p>
            </div>
          )}
          
          {/* Interface de s√©lection des lieux en mode DEBUG */}
          {debugMode && (
            <div className="mt-4 p-4 bg-purple-100 rounded-lg border border-purple-300 mb-4">
              <h3 className="font-bold text-purple-800 mb-2">MODE DEBUG - S√©lectionnez un lieu √† tester :</h3>
              <div className="grid grid-cols-1 gap-2">
                {locations.map((location, index) => (
                  <button
                    key={index}
                    onClick={() => selectDebugLocation(location)}
                    className={`p-2 rounded ${selectedDebugLocation && selectedDebugLocation.name === location.name ? 'bg-purple-500 text-white' : 'bg-white hover:bg-purple-200'}`}
                  >
                    {location.name}
                  </button>
                ))}
              </div>
              <div className="mt-3 text-sm text-purple-800">
                <span className="font-bold">Note:</span> En mode DEBUG, vous pouvez tester toutes les questions sans vous d√©placer physiquement.
              </div>
            </div>
          )}
          
          {nearbyLocation && (
            <div className={`${solvedLocations.includes(nearbyLocation.name) ? 'bg-green-100 border-green-400 text-green-700' : 'bg-yellow-100 border-yellow-400 text-yellow-700'} border px-4 py-3 rounded mb-4`}>
              <h3 className="font-bold">{nearbyLocation.name}</h3>
              
              {/* Affichage du mot crois√© ou de la question standard selon la location */}
              {nearbyLocation.usesCrossword ? (
                solvedLocations.includes(nearbyLocation.name) ? (
                  <div className="bg-white p-3 rounded">
                    <p>√ânigme r√©solue ! Vous avez obtenu la lettre : <span className="font-bold text-xl">{nearbyLocation.letter}</span></p>
                  </div>
                ) : (
                  <CrosswordPuzzle 
                    onSolve={handleCrosswordSolve} 
                    onWrongAnswer={loseLife}
                    debugMode={debugMode} 
                  />
                )
              ) : (
                <div>
                  <p className="mb-3">{nearbyLocation.question}</p>
                  
                  {nearbyLocation.image && (
                    <img 
                      src={nearbyLocation.image} 
                      alt={nearbyLocation.name} 
                      className="w-full h-40 object-cover rounded mb-3"
                    />
                  )}
                  
                  {solvedLocations.includes(nearbyLocation.name) ? (
                    <div className="bg-white p-3 rounded">
                      <p>√ânigme r√©solue ! Vous avez obtenu la lettre : <span className="font-bold text-xl">{nearbyLocation.letter}</span></p>
                    </div>
                  ) : lives <= 0 ? (
                    <div className="bg-red-100 p-3 rounded text-center">
                      <p className="text-red-700 font-bold">Vous n'avez plus de vies !</p>
                      <p className="text-red-600 text-sm mb-2">Envoyez un compliment √† Lo√Øs pour regagner une vie</p>
                      <button 
                        onClick={() => setShowComplimentModal(true)}
                        className="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded"
                      >
                        Regagner une vie
                      </button>
                    </div>
                  ) : (
                    <div>
                      {nearbyLocation.options && (
                        <div className="mb-3">
                          {nearbyLocation.options.map((option, idx) => (
                            <div 
                              key={idx} 
                              className={`p-2 mb-2 bg-white border rounded cursor-pointer hover:bg-yellow-50 ${userAnswer === option ? 'bg-yellow-100 border-yellow-500' : ''}`}
                              onClick={() => {
                                // Si l'option s√©lectionn√©e est exactement la r√©ponse attendue
                                if (option === nearbyLocation.answer) {
                                  setUserAnswer(option);
                                } 
                                // Pour les cas o√π la r√©ponse attendue est juste une partie de l'option
                                else if (option.includes(nearbyLocation.answer)) {
                                  setUserAnswer(nearbyLocation.answer);
                                }
                                // Sinon, sauvegarder l'option compl√®te
                                else {
                                  setUserAnswer(option);
                                }
                              }}
                            >
                              {option}
                            </div>
                          ))}
                        </div>
                      )}
                      <input
                        type="text"
                        value={userAnswer}
                        onChange={(e) => setUserAnswer(e.target.value)}
                        placeholder="Votre r√©ponse"
                        className="w-full p-2 border rounded mb-2"
                      />
                      <button 
                        onClick={checkAnswer}
                        className="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-medium py-2 px-4 rounded"
                      >
                        Valider
                      </button>
                    </div>
                  )}
                </div>
              )}
            </div>
          )}
          
          {/* Section pour deviner le mot secret */}
          <div className="mt-6 p-4 bg-purple-100 rounded-lg border border-purple-300">
            <h3 className="font-bold text-purple-800 mb-2">Lettres d√©couvertes :</h3>
            <div className="flex flex-wrap gap-2 mb-4">
              {getFoundLetters().split('').map((letter, index) => (
                <div key={index} className="w-10 h-10 flex items-center justify-center bg-purple-500 text-white font-bold rounded">
                  {letter}
                </div>
              ))}
              {getFoundLetters().length === 0 && (
                <p className="text-purple-700">Aucune lettre d√©couverte pour le moment...</p>
              )}
            </div>
            
            <h3 className="font-bold text-purple-800 mb-2">Mot secret :</h3>
            <div className="flex">
              <input
                type="text"
                value={secretWord}
                onChange={(e) => setSecretWord(e.target.value)}
                placeholder="Entrez le mot secret"
                className="flex-grow p-2 border rounded-l"
                disabled={lives <= 0}
              />
              <button 
                onClick={checkSecretWord}
                className={`bg-purple-500 hover:bg-purple-600 text-white font-medium py-2 px-4 rounded-r ${lives <= 0 ? 'opacity-50 cursor-not-allowed' : ''}`}
                disabled={lives <= 0}
              >
                V√©rifier
              </button>
            </div>
            
            {lives <= 0 && (
              <div className="mt-2 text-center text-red-600 text-sm">
                <p>Vous n'avez plus de vies. Regagnez des vies pour continuer.</p>
              </div>
            )}
          </div>
          
          <div className="mt-6">
            <h3 className="font-medium text-gray-700 mb-2">Lieux d'int√©r√™t √† d√©couvrir :</h3>
            <ul className="list-disc pl-5 text-gray-600">
              {locations.map((loc, index) => (
                <li key={index} className={solvedLocations.includes(loc.name) ? "line-through text-green-600" : ""}>
                  {loc.name}
                </li>
              ))}
            </ul>
          </div>
          
          {/* Modal pour gagner une vie */}
          {showComplimentModal && (
            <ComplimentModal 
              onClose={() => setShowComplimentModal(false)}
              onLifeGained={gainLife}
            />
          )}
          
          {/* Modal de perte de vie */}
          {showLifeLostModal && (
            <div className="life-modal">
              <div className="modal-content bg-red-100">
                <div className="text-4xl mb-2">üíî</div>
                <h3 className="text-xl font-bold mb-2 text-red-700">Vous avez perdu une vie!</h3>
                <p className="mb-3">Il vous reste {lives} vie(s).</p>
                {lives === 0 && (
                  <button 
                    onClick={() => {
                      setShowLifeLostModal(false);
                      setShowComplimentModal(true);
                    }}
                    className="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded"
                  >
                    Regagner une vie
                  </button>
                )}
              </div>
            </div>
          )}
        </div>
      );
    };

    ReactDOM.render(<TreasureHunt />, document.getElementById('root'));
  </script>
</body>
</html>